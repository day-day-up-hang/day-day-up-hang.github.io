<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="unique_Hang&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="unique_Hang&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="unique_Hang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>unique_Hang's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">unique_Hang's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/09/C++%E7%AA%81%E5%87%BB%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/C++%E7%AA%81%E5%87%BB%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">C++突击面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-09 12:47:02 / Modified: 12:48:03" itemprop="dateCreated datePublished" datetime="2022-05-09T12:47:02+08:00">2022-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开<br>作者邮箱：<a href="mailto:&#117;&#x6e;&#105;&#x71;&#x75;&#x65;&#95;&#x68;&#97;&#110;&#x67;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#117;&#x6e;&#105;&#x71;&#x75;&#x65;&#95;&#x68;&#97;&#110;&#x67;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<h1 id="C-突击面试"><a href="#C-突击面试" class="headerlink" title="C++突击面试"></a>C++突击面试</h1><h1 id="1-编译内存相关"><a href="#1-编译内存相关" class="headerlink" title="1. 编译内存相关"></a>1. 编译内存相关</h1><h2 id="1-1-C-程序编译过程"><a href="#1-1-C-程序编译过程" class="headerlink" title="1.1. C++ 程序编译过程"></a>1.1. C++ 程序编译过程</h2><p>编译过程分为四个过程：编译（编译<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">预处理</a>、编译、优化），汇编，链接。</p>
<ul>
<li><p><strong>编译预处理</strong>：处理以 # 开头的指令；</p>
</li>
<li><p><strong>编译、优化</strong>：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</li>
<li><p><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</li>
<li><p><strong>链接</strong>：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe文件。<br><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h221mhoy4yj312u10igqn.jpg" alt="在这里插入图片描述"><br>链接分为两种：</p>
</li>
<li><p><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
</li>
<li><p><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>二者的优缺点：</p>
</li>
<li><p><strong>静态链接</strong>：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</p>
</li>
<li><p><strong>动态链接</strong>：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</p>
</li>
</ul>
<h2 id="1-2-C-内存管理"><a href="#1-2-C-内存管理" class="headerlink" title="1.2. C++ 内存管理"></a>1.2. C++ <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&spm=1001.2101.3001.7020">内存管理</a></h2><p>C++ 内存分区：<strong>栈、堆、全局&#x2F;静态存储区、常量存储区、代码区</strong>。</p>
<ul>
<li><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li>
<li><strong>堆</strong>：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li>
<li><strong>全局区&#x2F;静态存储区（.bss 段和 .data 段）</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在.bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li>
<li><strong>常量存储区（.data 段</strong>）：存放的是常量，不允许修改，程序运行结束自动释放。</li>
<li><strong>代码区（.text 段）</strong>：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li>
</ul>
<h2 id="1-3-栈和堆的区别"><a href="#1-3-栈和堆的区别" class="headerlink" title="1.3. 栈和堆的区别"></a>1.3. 栈和堆的区别</h2><ul>
<li><strong>申请方式</strong>：栈是系统自动分配，堆是程序员主动申请。</li>
<li><strong>申请后系统响应</strong>：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li>
<li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li>
<li><strong>申请效率</strong>：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li>
<li><strong>存放的内容</strong>：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li>
</ul>
<h2 id="1-4-变量的区别"><a href="#1-4-变量的区别" class="headerlink" title="1.4. 变量的区别"></a>1.4. 变量的区别</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">全局变量</a>、局部变量、静态全局变量、静态局部变量的区别：</p>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<p><strong>从作用域看：</strong></p>
<ul>
<li><strong>全局变量</strong>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。</li>
<li><strong>静态全局变量</strong>：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li>
<li><strong>局部变量</strong>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li>
<li><strong>静态局部变量</strong>：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li>
</ul>
<p>从分配内存空间看：</p>
<ul>
<li><strong>静态存储区</strong>：全局变量，静态局部变量，静态全局变量。</li>
<li><strong>栈</strong>：局部变量。</li>
</ul>
<h2 id="1-5-全局变量定义在头文件中有什么问题？"><a href="#1-5-全局变量定义在头文件中有什么问题？" class="headerlink" title="1.5. 全局变量定义在头文件中有什么问题？"></a>1.5. 全局变量定义在头文件中有什么问题？</h2><p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
<h2 id="1-6-内存对齐"><a href="#1-6-内存对齐" class="headerlink" title="1.6. 内存对齐"></a>1.6. 内存对齐</h2><p><strong>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</strong></p>
<p><strong>内存对齐</strong>：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中<br>内存对齐的原则：</p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量 （offset）<br>都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li>
</ol>
<p><strong>进行内存对齐的原因</strong>：（主要是硬件设备方面的问题）</p>
<ol>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignmenttrap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ol>
<p><strong>内存对齐的优点</strong>：</p>
<ol>
<li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li>
<li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li>
</ol>
<h2 id="1-7-什么是内存泄露"><a href="#1-7-什么是内存泄露" class="headerlink" title="1.7. 什么是内存泄露"></a>1.7. 什么是内存泄露</h2><p>内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。<br>进一步解释：</p>
<ul>
<li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li>
<li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li>
<li>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。</li>
<li>指针重新赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *p = (char *)malloc(10);</span><br><span class="line">char *p1 = (char *)malloc(10);</span><br><span class="line">p = np;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<h2 id="1-8-怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#1-8-怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="1.8. 怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>1.8. 怎么防止内存泄漏？内存泄漏检测工具的原理？</h2><p><strong>防止内存泄漏的方法：</strong></p>
<ol>
<li><strong>内部封装</strong>：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）</li>
<li><strong>智能指针</strong>：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</li>
</ol>
<p><strong>内存泄漏检测工具的实现原理：</strong><br>内存检测工具有很多，这里重点介绍下 valgrind 。</p>
<h2 id="1-9-智能指针有哪几种？智能指针的实现原理？"><a href="#1-9-智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="1.9. 智能指针有哪几种？智能指针的实现原理？"></a>1.9. 智能指针有哪几种？智能指针的实现原理？</h2><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <strong>&lt; memory &gt;</strong> 头文件中。</p>
<p>C++11 中智能指针包括以下三种：</p>
<ul>
<li><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li>
<li><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</li>
<li><strong>弱指针（weak_ptr）</strong>：指向 shared_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。</li>
</ul>
<p><strong>智能指针的实现原理：</strong> 计数原理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPtr</span><br><span class="line">&#123;</span><br><span class="line">private : </span><br><span class="line">	T *_ptr;</span><br><span class="line">	size_t *_count;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	SmartPtr(T *ptr = nullptr) : _ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		if (_ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			_count = new size_t(1);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			_count = new size_t(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~SmartPtr()</span><br><span class="line">	&#123;</span><br><span class="line">		(*this-&gt;_count)--;</span><br><span class="line">		if (*this-&gt;_count == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			delete this-&gt;_ptr;</span><br><span class="line">			delete this-&gt;_count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SmartPtr(const SmartPtr &amp;ptr) // 拷贝构造：计数 +1</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;_ptr = ptr._ptr;</span><br><span class="line">			this-&gt;_count = ptr._count;</span><br><span class="line">			(*this-&gt;_count)++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SmartPtr &amp;operator=(const SmartPtr &amp;ptr) // 赋值运算符重载 </span><br><span class="line">	&#123;</span><br><span class="line">		if (this-&gt;_ptr == ptr._ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		if (this-&gt;_ptr) // 将当前的 ptr 指向的原来的空间的计数 -1</span><br><span class="line">		&#123;</span><br><span class="line">			(*this-&gt;_count)--;</span><br><span class="line">			if (this-&gt;_count == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				delete this-&gt;_ptr;</span><br><span class="line">				delete this-&gt;_count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;_ptr = ptr._ptr;</span><br><span class="line">		this-&gt;_count = ptr._count;</span><br><span class="line">		(*this-&gt;_count)++; // 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T &amp;operator*()</span><br><span class="line">	&#123;</span><br><span class="line">		assert(this-&gt;_ptr == nullptr);</span><br><span class="line">		return *(this-&gt;_ptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T *operator-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		assert(this-&gt;_ptr == nullptr);</span><br><span class="line">		return this-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size_t use_count()</span><br><span class="line">	&#123;</span><br><span class="line">		return *this-&gt;count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081</span><br></pre></td></tr></table></figure>

<h2 id="1-10-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？"><a href="#1-10-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？" class="headerlink" title="1.10. 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？"></a>1.10. 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h2><p>借助 <strong>std::move()</strong> 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// A 作为一个类 </span><br><span class="line">std::unique_ptr&lt;A&gt; ptr1(new A());</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr2 = std::move(ptr1);</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h2 id="1-11-使用智能指针会出现什么问题？怎么解决？"><a href="#1-11-使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="1.11. 使用智能指针会出现什么问题？怎么解决？"></a>1.11. 使用智能指针会出现什么问题？怎么解决？</h2><p><strong>智能指针可能出现的问题：循环引用</strong></p>
<p>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Child;</span><br><span class="line">class Parent;</span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line">private:</span><br><span class="line">    shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line">public:</span><br><span class="line">    void setChild(shared_ptr&lt;Child&gt; child) &#123;</span><br><span class="line">        this-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        if (this-&gt;ChildPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child &#123;</span><br><span class="line">private:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line">public:</span><br><span class="line">    void setPartent(shared_ptr&lt;Parent&gt; parent) &#123;</span><br><span class="line">        this-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        if (this-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;Parent&gt; p(new Parent);</span><br><span class="line">        shared_ptr&lt;Child&gt; c(new Child);</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2</span><br><span class="line">        cout &lt;&lt; c.use_count() &lt;&lt; endl; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.use_count() &lt;&lt; endl;  // 1</span><br><span class="line">    cout &lt;&lt; wpc.use_count() &lt;&lt; endl;  // 1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span><br></pre></td></tr></table></figure>

<p><strong>循环引用的解决方法： weak_ptr</strong></p>
<p><strong>循环引用</strong>：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p>
<ul>
<li>weak_ptr 对被 shared_ptr 管理的对象存在<strong>非拥有性（弱）引用</strong>，在访问所引用的对象前必须先转化为 shared_ptr；</li>
<li>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li>
<li>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Child;</span><br><span class="line">class Parent;</span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line">private:</span><br><span class="line">    //shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line">public:</span><br><span class="line">    void setChild(shared_ptr&lt;Child&gt; child) &#123;</span><br><span class="line">        this-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        //new shared_ptr</span><br><span class="line">        if (this-&gt;ChildPtr.lock()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child &#123;</span><br><span class="line">private:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line">public:</span><br><span class="line">    void setPartent(shared_ptr&lt;Parent&gt; parent) &#123;</span><br><span class="line">        this-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        if (this-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;Parent&gt; p(new Parent);</span><br><span class="line">        shared_ptr&lt;Child&gt; c(new Child);</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2</span><br><span class="line">        cout &lt;&lt; c.use_count() &lt;&lt; endl; // 1</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.use_count() &lt;&lt; endl;  // 0</span><br><span class="line">    cout &lt;&lt; wpc.use_count() &lt;&lt; endl;  // 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061</span><br></pre></td></tr></table></figure>

<h1 id="2-语言对比"><a href="#2-语言对比" class="headerlink" title="2. 语言对比"></a>2. 语言对比</h1><h2 id="2-1-C-11-新特性"><a href="#2-1-C-11-新特性" class="headerlink" title="2.1 C++ 11 新特性"></a>2.1 C++ 11 新特性</h2><p><strong>1. auto 类型推导</strong><br>auto 关键字：自动类型推导，编译器会在 <strong>编译期间</strong> 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。<br>auto 关键字基本的使用语法如下：</p>
<p><strong>2. decltype 类型推导</strong><br>decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。</p>
<p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto var = val1 + val2; </span><br><span class="line">decltype(val1 + val2) var1 = 0; </span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<ul>
<li>auto 根据 <strong>&#x3D;</strong> 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</li>
<li>auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。</li>
</ul>
<p><strong>3. lambda 表达式</strong><br>lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。</p>
<p>lambda匿名函数的定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; return type</span><br><span class="line">&#123;</span><br><span class="line">   function body;</span><br><span class="line">&#125;;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</li>
<li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[4] = &#123;4, 2, 3, 1&#125;;</span><br><span class="line">    //对 a 数组中的元素进行升序排序</span><br><span class="line">    sort(arr, arr+4, [=](int x, int y) -&gt; bool&#123; return x &lt; y; &#125; );</span><br><span class="line">    for(int n : arr)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p><strong>4. 范围 for 语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (declaration : expression)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>参数的含义：</p>
<ul>
<li>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。</li>
<li>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。</li>
</ul>
<p><strong>5. 右值引用</strong><br>右值引用：绑定到右值的引用，用 <strong>&amp;&amp;</strong> 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var = 42;</span><br><span class="line">    int &amp;l_var = var;</span><br><span class="line">    int &amp;&amp;r_var = var; // error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上</span><br><span class="line"></span><br><span class="line">    int &amp;&amp;r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure>

<p><strong>6. 标准库 move() 函数</strong><br>move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。该知识点会在后续的章节中做详细的说明。</p>
<p><strong>7. 智能指针</strong><br>相关知识已在第一章中进行了详细的说明，这里不再重复。</p>
<p><strong>8. delete 函数和 default 函数</strong></p>
<ul>
<li>delete 函数：&#x3D; delete 表示该函数不能被调用。</li>
<li>default 函数：&#x3D; default 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A() = default; // 表示使用默认的构造函数</span><br><span class="line">	~A() = default;	// 表示使用默认的析构函数</span><br><span class="line">	A(const A &amp;) = delete; // 表示类的对象禁止拷贝构造</span><br><span class="line">	A &amp;operator=(const A &amp;) = delete; // 表示类的对象禁止拷贝赋值</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A ex1;</span><br><span class="line">	A ex2 = ex1; // error: use of deleted function &#x27;A::A(const A&amp;)&#x27;</span><br><span class="line">	A ex3;</span><br><span class="line">	ex3 = ex1; // error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure>

<h2 id="2-2-C-和-C-的区别"><a href="#2-2-C-和-C-的区别" class="headerlink" title="2.2 C 和 C++ 的区别"></a>2.2 C 和 C++ 的区别</h2><p>首先说一下<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">面向对象</a>和面向过程：</p>
<ul>
<li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li>
<li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li>
</ul>
<p>区别和联系：</p>
<ul>
<li>语言自身：C 语言是面向过程的编程，它最重要的特点是函数，通过 main<br>函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</li>
<li>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li>
<li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 const 关键字，等等。</li>
<li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li>
</ul>
<h2 id="2-3-Python-和-C-的区别"><a href="#2-3-Python-和-C-的区别" class="headerlink" title="2.3 Python 和 C++ 的区别"></a>2.3 Python 和 C++ 的区别</h2><p>区别：</p>
<ul>
<li>语言自身：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li>
<li>运行效率：C++ 运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成 CPU指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li>
<li>开发效率：Python 开发效率高。原因：Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li>
<li>书写格式和语法不同：Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</li>
</ul>
<h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h1><h2 id="3-1-什么是面向对象？面向对象的三大特性"><a href="#3-1-什么是面向对象？面向对象的三大特性" class="headerlink" title="3.1 什么是面向对象？面向对象的三大特性"></a>3.1 什么是面向对象？面向对象的三大特性</h2><p><strong>面向对象</strong>：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p>
<p>面向对象的三大特性：</p>
<ul>
<li><strong>封装</strong>：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li>
<li><strong>继承</strong>：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li>
<li><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li>
</ul>
<h2 id="3-2-重载、重写、隐藏的区别"><a href="#3-2-重载、重写、隐藏的区别" class="headerlink" title="3.2 重载、重写、隐藏的区别"></a>3.2 重载、重写、隐藏的区别</h2><ol>
<li><strong>重载</strong>：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(int tmp);</span><br><span class="line">    void fun(float tmp);        // 重载 参数类型不同（相对于上一个函数）</span><br><span class="line">    void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数）</span><br><span class="line">    void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数）</span><br><span class="line">    int fun(int tmp);            // error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span><br><span class="line">&#125;;</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>隐藏</strong>：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(int tmp, float tmp1) &#123; cout &lt;&lt; &quot;Base::fun(int tmp, float tmp1)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(int tmp) &#123; cout &lt;&lt; &quot;Derive::fun(int tmp)&quot; &lt;&lt; endl; &#125; // 隐藏基类中的同名函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.fun(1);       // Derive::fun(int tmp)</span><br><span class="line">    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</p>
<ol>
<li>**重写(覆盖)**：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun(int tmp) &#123; cout &lt;&lt; &quot;Base::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun(int tmp) &#123; cout &lt;&lt; &quot;Derived::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; &#125; // 重写基类中的 fun 函数</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p = new Derived();</span><br><span class="line">    p-&gt;fun(3); // Derived::fun(int) : 3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<p><strong>重写和重载的区别：</strong></p>
<ul>
<li><strong>范围区别</strong>：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li><strong>参数区别</strong>：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</li>
<li><strong>virtual 关键字</strong>：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li>
</ul>
<p><strong>隐藏和重写，重载的区别：</strong></p>
<ul>
<li><strong>范围区别</strong>：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li><strong>参数区别</strong>：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual<br>修饰，基类函数都是被隐藏，而不是重写。</li>
</ul>
<h2 id="3-3-如何理解-C-是面向对象编程"><a href="#3-3-如何理解-C-是面向对象编程" class="headerlink" title="3.3 如何理解 C++ 是面向对象编程"></a>3.3 如何理解 C++ 是面向对象编程</h2><p>说明：该问题最好结合自己的项目经历进行展开解释，或举一些恰当的例子，同时对比下面向过程编程。</p>
<ul>
<li><strong>面向过程编程</strong>：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li>
<li><strong>面向对象编程（Object-Oriented Programming, OOP）</strong>：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</li>
</ul>
<p><strong>面向对象编程进一步说明：</strong></p>
<p>面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（public、private、protected），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</p>
<h2 id="3-4-什么是多态？多态如何实现？"><a href="#3-4-什么是多态？多态如何实现？" class="headerlink" title="3.4 什么是多态？多态如何实现？"></a>3.4 什么是多态？多态如何实现？</h2><p><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<p><strong>实现方法</strong>：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p><strong>实现过程：</strong></p>
<ol>
<li>在类中用 virtual 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base *p = new Derive();</span><br><span class="line">	p-&gt;fun(); // Derive::fun() 调用派生类中的虚函数</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<p>基类的虚函数表如下：<br><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h221ne0x20j30gg09iaan.jpg" alt="在这里插入图片描述"><br>派生类的对象虚函数表如下：<br><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h221nitgtlj30m809hq3n.jpg" alt="在这里插入图片描述"><br>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p>
<h1 id="4-关键字库函数"><a href="#4-关键字库函数" class="headerlink" title="4. 关键字库函数"></a>4. 关键字<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BA%93%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">库函数</a></h1><h2 id="4-1-sizeof-和-strlen-的区别"><a href="#4-1-sizeof-和-strlen-的区别" class="headerlink" title="4.1 sizeof 和 strlen 的区别"></a>4.1 sizeof 和 strlen 的区别</h2><ol>
<li>strlen 是头文件 中的函数，sizeof 是 C++ 中的运算符。</li>
<li>strlen 测量的是字符串的实际长度（其源代码如下），以 <strong>\0</strong> 结束。而 sizeof 测量的是字符数组的分配大小。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strlen 源代码:</span><br><span class="line">size_t strlen(const char *str) &#123;</span><br><span class="line">    size_t length = 0;</span><br><span class="line">    while (*str++)</span><br><span class="line">        ++length;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr[10] = &quot;hello&quot;;</span><br><span class="line">    cout &lt;&lt; strlen(arr) &lt;&lt; endl; // 5</span><br><span class="line">    cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // 10</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<ol>
<li>若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void size_of(char arr[])</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span><br><span class="line">    cout &lt;&lt; strlen(arr) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr[20] = &quot;hello&quot;;</span><br><span class="line">    size_of(arr); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出结果：</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">*/</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<ol>
<li>strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；</li>
<li>sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。</li>
</ol>
<h2 id="4-2-lambda-表达式（匿名函数）的具体应用和使用场景"><a href="#4-2-lambda-表达式（匿名函数）的具体应用和使用场景" class="headerlink" title="4.2 lambda 表达式（匿名函数）的具体应用和使用场景"></a>4.2 lambda 表达式（匿名函数）的具体应用和使用场景</h2><p>lambda 表达式的定义形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; reurn type</span><br><span class="line">&#123;</span><br><span class="line">   function body</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [&#x3D;]。</li>
<li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li>
</ul>
<p>举例：<br>lambda 表达式常搭配排序算法使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; arr = &#123;3, 4, 76, 12, 54, 90, 34&#125;;</span><br><span class="line">    sort(arr.begin(), arr.end(), [](int a, int b) &#123; return a &gt; b; &#125;); // 降序排序</span><br><span class="line">    for (auto a : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">运行结果：90 76 54 34 12 4 3</span><br><span class="line">*/</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<h2 id="4-3-explicit-的作用（如何避免编译器进行隐式类型转换）"><a href="#4-3-explicit-的作用（如何避免编译器进行隐式类型转换）" class="headerlink" title="4.3 explicit 的作用（如何避免编译器进行隐式类型转换）"></a>4.3 explicit 的作用（如何避免编译器进行隐式类型转换）</h2><p>作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p>
<p>隐式转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var;</span><br><span class="line">    A(int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A ex = 10; // 发生了隐式转换</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<p>上述代码中，A ex &#x3D; 10; 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：</p>
<p>为了避免隐式转换，可用 explicit 关键字进行声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var;</span><br><span class="line">    explicit A(int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A ex(100);</span><br><span class="line">    A ex1 = 10; // error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<h2 id="4-4-C-和-C-static-的区别"><a href="#4-4-C-和-C-static-的区别" class="headerlink" title="4.4 C 和 C++ static 的区别"></a>4.4 C 和 C++ static 的区别</h2><ul>
<li>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数</li>
<li>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</li>
</ul>
<h2 id="4-5-static-的作用"><a href="#4-5-static-的作用" class="headerlink" title="4.5 static 的作用"></a>4.5 static 的作用</h2><p>作用：<br>static 定义静态变量，静态函数。</p>
<ul>
<li>保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fun()&#123;</span><br><span class="line">    static int var = 1; // var 只在第一次进入这个函数的时初始化</span><br><span class="line">    var += 1;</span><br><span class="line">    return var;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10; ++i)</span><br><span class="line">    	cout &lt;&lt; fun() &lt;&lt; &quot; &quot;; // 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<ul>
<li>隐藏：static作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</li>
<li>static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int var;</span><br><span class="line">    static int s_var; // 静态成员变量</span><br><span class="line">public:</span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s_var++ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static void s_show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s_var &lt;&lt; endl;</span><br><span class="line">		// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span><br><span class="line">        // show();  // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int A::s_var = 1;  // 静态成员变量在类外进行初始化赋值，默认初始化为 0</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // cout &lt;&lt; A::sa &lt;&lt; endl;    // error: &#x27;int A::sa&#x27; is private within this context</span><br><span class="line">    A ex;</span><br><span class="line">    ex.show();</span><br><span class="line">    A::s_show();</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure>

<h2 id="4-6-static-在类中使用的注意事项（定义、初始化和使用）"><a href="#4-6-static-在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="4.6 static 在类中使用的注意事项（定义、初始化和使用）"></a>4.6 static 在类中使用的注意事项（定义、初始化和使用）</h2><p>static 静态成员变量：</p>
<ol>
<li>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现<br>static关键字和private、public、protected 访问规则。</li>
<li>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</li>
<li>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static int s_var;</span><br><span class="line">    int var;</span><br><span class="line">    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数</span><br><span class="line">    void fun2(int i = var);   //  error: invalid use of non-static data member &#x27;A::var&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<ol>
<li>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static A s_var; // 正确，静态数据成员</span><br><span class="line">    A var;          // error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span><br><span class="line">    A *p;           // 正确，指针</span><br><span class="line">    A &amp;var1;        // 正确，引用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>static 静态成员函数：</p>
<ol>
<li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。</li>
<li>静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。</li>
</ol>
<h2 id="4-7-static-全局变量和普通全局变量的异同"><a href="#4-7-static-全局变量和普通全局变量的异同" class="headerlink" title="4.7 static 全局变量和普通全局变量的异同"></a>4.7 static 全局变量和普通全局变量的异同</h2><p><strong>相同点：</strong></p>
<ul>
<li>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
<li>初始化：静态全局变量只初始化一次，防止在其他文件中使用。</li>
</ul>
<h2 id="4-8-const-作用及用法"><a href="#4-8-const-作用及用法" class="headerlink" title="4.8 const 作用及用法"></a>4.8 const 作用及用法</h2><p><strong>作用：</strong></p>
<ul>
<li>const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li>
<li>const 修饰函数参数，使得传递过来的函数参数的值不能改变。</li>
<li>const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</li>
</ul>
<p><strong>在类中的用法：</strong></p>
<p>const 成员变量：</p>
<ul>
<li>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</li>
</ul>
<p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ul>
<h2 id="4-9-define-和-const-的区别"><a href="#4-9-define-和-const-的区别" class="headerlink" title="4.9 define 和 const 的区别"></a>4.9 define 和 const 的区别</h2><p>区别：</p>
<ul>
<li>编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</li>
<li>安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
<li>内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</li>
<li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；cons定义的常量可以进行调试。</li>
</ul>
<p>const 的优点：</p>
<ul>
<li>有数据类型，在定义式可进行安全性检查。</li>
<li>可调式。</li>
<li>占用较少的空间。</li>
</ul>
<h2 id="4-10-define-和-typedef-的区别"><a href="#4-10-define-和-typedef-的区别" class="headerlink" title="4.10 define 和 typedef 的区别"></a>4.10 define 和 typedef 的区别</h2><ul>
<li>原理：#define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 。</li>
<li>功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
<li>作用域：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef 有自己的作用域。</li>
<li>指针的操作：typedef 和 #define 在处理指针时不完全一样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define INTPTR1 int *</span><br><span class="line">typedef int * INTPTR2;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INTPTR1 p1, p2; // p1: int *; p2: int</span><br><span class="line">    INTPTR2 p3, p4; // p3: int *; p4: int *</span><br><span class="line"></span><br><span class="line">    int var = 1;</span><br><span class="line">    const INTPTR1 p5 = &amp;var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span><br><span class="line">    const INTPTR2 p6 = &amp;var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure>

<h2 id="4-11-用宏实现比较大小，以及两个数中的最小值"><a href="#4-11-用宏实现比较大小，以及两个数中的最小值" class="headerlink" title="4.11 用宏实现比较大小，以及两个数中的最小值"></a>4.11 用宏实现比较大小，以及两个数中的最小值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define MAX(X, Y) ((X)&gt;(Y)?(X):(Y))</span><br><span class="line">#define MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int var1 = 10, var2 = 100;</span><br><span class="line">    cout &lt;&lt; MAX(var1, var2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; MIN(var1, var2) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">程序运行结果：</span><br><span class="line">100</span><br><span class="line">10</span><br><span class="line">*/</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure>

<h2 id="4-12-inline-作用及使用方法"><a href="#4-12-inline-作用及使用方法" class="headerlink" title="4.12 inline 作用及使用方法"></a>4.12 inline 作用及使用方法</h2><p><strong>作用：</strong><br>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p>
<p><strong>使用方法：</strong></p>
<ol>
<li>类内定义成员函数默认是内联函数<br>在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    int var;</span><br><span class="line">    A(int tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    void fun()&#123; </span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<ol>
<li>类外定义成员函数，若想定义为内联函数，需用关键字声明<br>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    int var;</span><br><span class="line">    A(int tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    void fun();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void A::fun()&#123;</span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<p>另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。</p>
<h2 id="4-13-inline-函数工作原理"><a href="#4-13-inline-函数工作原理" class="headerlink" title="4.13 inline 函数工作原理"></a>4.13 inline 函数工作原理</h2><ul>
<li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li>
<li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li>
</ul>
<h2 id="4-14-宏定义（define）和内联函数（inline）的区别"><a href="#4-14-宏定义（define）和内联函数（inline）的区别" class="headerlink" title="4.14 宏定义（define）和内联函数（inline）的区别"></a>4.14 宏定义（define）和内联函数（inline）的区别</h2><ol>
<li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li>
<li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li>
<li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int fun_max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var = 1;</span><br><span class="line">    cout &lt;&lt; MAX(var, 5) &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; fun_max(var, 0) &lt;&lt; endl; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">程序运行结果：</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">123456789101112131415161718192021222324</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-15-new-的作用？"><a href="#4-15-new-的作用？" class="headerlink" title="4.15 new 的作用？"></a>4.15 new 的作用？</h2><p>new 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int[5]; </span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-16-new-和-malloc-如何判断是否申请到内存？"><a href="#4-16-new-和-malloc-如何判断是否申请到内存？" class="headerlink" title="4.16 new 和 malloc 如何判断是否申请到内存？"></a>4.16 new 和 malloc 如何判断是否申请到内存？</h2><ul>
<li>malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。</li>
<li>new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bac_alloc 异常。</li>
</ul>
<h2 id="4-17-delete-实现原理？delete-和-delete-的区别？"><a href="#4-17-delete-实现原理？delete-和-delete-的区别？" class="headerlink" title="4.17 delete 实现原理？delete 和 delete[] 的区别？"></a>4.17 delete 实现原理？delete 和 delete[] 的区别？</h2><p><strong>delete 的实现原理：</strong></p>
<ul>
<li>首先执行该对象所属类的析构函数；</li>
<li>进而通过调用 operator delete 的标准库函数来释放所占的内存空间。</li>
</ul>
<p><strong>delete 和 delete [] 的区别：</strong></p>
<ul>
<li>delete 用来释放单个对象所占的空间，只会调用一次析构函数；</li>
<li>delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li>
</ul>
<h2 id="4-18-new-和-malloc-的区别，delete-和-free-的区别"><a href="#4-18-new-和-malloc-的区别，delete-和-free-的区别" class="headerlink" title="4.18 new 和 malloc 的区别，delete 和 free 的区别"></a>4.18 new 和 malloc 的区别，delete 和 free 的区别</h2><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p>
<ul>
<li>malloc、free 是库函数，而new、delete 是关键字。</li>
<li>new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。</li>
<li>new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li>
<li>new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。</li>
<li>对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。</li>
<li>new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）</li>
</ul>
<h2 id="4-19-malloc-的原理？malloc-的底层实现？"><a href="#4-19-malloc-的原理？malloc-的底层实现？" class="headerlink" title="4.19 malloc 的原理？malloc 的底层实现？"></a>4.19 malloc 的原理？malloc 的底层实现？</h2><p><strong>malloc 的原理:</strong></p>
<ul>
<li>当开辟的空间小于 128K 时，调用 brk() 函数，通过移动 _enddata 来实现；</li>
<li>当开辟空间大于 128K 时，调用 mmap() 函数，通过在虚拟地址空间中开辟一块内存空间来实现。</li>
</ul>
<p><strong>malloc 的底层实现：</strong></p>
<ul>
<li>brk() 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 _enddata。</li>
<li>mmap 内存映射原理：<br>1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；<br>2.调用内核空间的系统调用函数 mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；<br>3.进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</li>
</ul>
<h2 id="4-20-C-和-C-struct-的区别？"><a href="#4-20-C-和-C-struct-的区别？" class="headerlink" title="4.20 C 和 C++ struct 的区别？"></a>4.20 C 和 C++ struct 的区别？</h2><ul>
<li>在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。</li>
<li>C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。</li>
<li>C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var;</li>
</ul>
<h2 id="4-21-为什么有了-class-还保留-struct？"><a href="#4-21-为什么有了-class-还保留-struct？" class="headerlink" title="4.21 为什么有了 class 还保留 struct？"></a>4.21 为什么有了 class 还保留 struct？</h2><ul>
<li>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 struct。</li>
</ul>
<h2 id="4-22-struct-和-union-的区别"><a href="#4-22-struct-和-union-的区别" class="headerlink" title="4.22 struct 和 union 的区别"></a>4.22 struct 和 union 的区别</h2><p>说明：union 是联合体，struct 是结构体。</p>
<p>区别：</p>
<ul>
<li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li>
<li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li>
<li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef union</span><br><span class="line">&#123;</span><br><span class="line">    char c[10];</span><br><span class="line">    char cc1; // char 1 字节，按该类型的倍数分配大小</span><br><span class="line">&#125; u11;</span><br><span class="line"></span><br><span class="line">typedef union</span><br><span class="line">&#123;</span><br><span class="line">    char c[10];</span><br><span class="line">    int i; // int 4 字节，按该类型的倍数分配大小</span><br><span class="line">&#125; u22;</span><br><span class="line"></span><br><span class="line">typedef union</span><br><span class="line">&#123;</span><br><span class="line">    char c[10];</span><br><span class="line">    double d; // double 8 字节，按该类型的倍数分配大小</span><br><span class="line">&#125; u33;</span><br><span class="line"></span><br><span class="line">typedef struct s1</span><br><span class="line">&#123;</span><br><span class="line">    char c;   // 1 字节</span><br><span class="line">    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br><span class="line">&#125; s11;</span><br><span class="line"></span><br><span class="line">typedef struct s2</span><br><span class="line">&#123;</span><br><span class="line">    char c;   // 1 字节</span><br><span class="line">    char cc;  // 1（char）+ 1（char）= 2 字节</span><br><span class="line">    double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节</span><br><span class="line">&#125; s22;</span><br><span class="line"></span><br><span class="line">typedef struct s3</span><br><span class="line">&#123;</span><br><span class="line">    char c;   // 1 字节</span><br><span class="line">    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br><span class="line">    char cc;  // 16 + 1（char）+ 7（内存对齐）= 24 字节</span><br><span class="line">&#125; s33;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(u11) &lt;&lt; endl; // 10</span><br><span class="line">    cout &lt;&lt; sizeof(u22) &lt;&lt; endl; // 12</span><br><span class="line">    cout &lt;&lt; sizeof(u33) &lt;&lt; endl; // 16</span><br><span class="line">    cout &lt;&lt; sizeof(s11) &lt;&lt; endl; // 16</span><br><span class="line">    cout &lt;&lt; sizeof(s22) &lt;&lt; endl; // 16</span><br><span class="line">    cout &lt;&lt; sizeof(s33) &lt;&lt; endl; // 24</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    // 4</span><br><span class="line">    cout &lt;&lt; sizeof(double) &lt;&lt; endl; // 8</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-23-class-和-struct-的异同"><a href="#4-23-class-和-struct-的异同" class="headerlink" title="4.23 class 和 struct 的异同"></a>4.23 class 和 struct 的异同</h2><ul>
<li>struct 和 class 都可以自定义数据类型，也支持继承操作。</li>
<li>struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。</li>
<li>当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身，class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;&#125;；</span><br><span class="line">class B : A&#123;&#125;; // private 继承 </span><br><span class="line">struct C : B&#123;&#125;； // public 继承</span><br><span class="line">123</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void funA()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;class A&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B: A&#123; // 由于 B 是 struct，A 的默认继承级别为 public</span><br><span class="line">public:</span><br><span class="line">    void funB()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;class B&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C: B&#123; // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    A ex1;</span><br><span class="line">    ex1.funA(); // class A</span><br><span class="line"></span><br><span class="line">    B ex2;</span><br><span class="line">    ex2.funA(); // class A</span><br><span class="line">    ex2.funB(); // class B</span><br><span class="line"></span><br><span class="line">    C ex3;</span><br><span class="line">    ex3.funB(); // error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;.</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>class 可以用于定义模板参数，struct 不能用于定义模板参数。</li>
</ul>
<h2 id="4-24-volatile-的作用？是否具有原子性，对编译器有什么影响？"><a href="#4-24-volatile-的作用？是否具有原子性，对编译器有什么影响？" class="headerlink" title="4.24 volatile 的作用？是否具有原子性，对编译器有什么影响？"></a>4.24 volatile 的作用？是否具有原子性，对编译器有什么影响？</h2><p><strong>volatile 的作用</strong>：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。</p>
<p>volatile不具有原子性。</p>
<p><strong>volatile 对编译器的影响</strong>：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p>
<h2 id="4-25-什么情况下一定要用-volatile，-能否和-const-一起使用？"><a href="#4-25-什么情况下一定要用-volatile，-能否和-const-一起使用？" class="headerlink" title="4.25 什么情况下一定要用 volatile， 能否和 const 一起使用？"></a>4.25 什么情况下一定要用 volatile， 能否和 const 一起使用？</h2><p>使用 volatile 关键字的场景：</p>
<ul>
<li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰。</li>
</ul>
<p>volatile 关键字和 const 关键字可以同时使用，某种类型可以既是 volatile 又是 const ，同时具有二者的属性。</p>
<h2 id="4-26-返回函数中静态变量的地址会发生什么？"><a href="#4-26-返回函数中静态变量的地址会发生什么？" class="headerlink" title="4.26 返回函数中静态变量的地址会发生什么？"></a>4.26 返回函数中静态变量的地址会发生什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int * fun(int tmp)&#123;</span><br><span class="line">    static int var = 10;</span><br><span class="line">    var *= tmp;</span><br><span class="line">    return &amp;var;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; *fun(5) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line">50</span><br><span class="line">*/</span><br><span class="line">123456789101112131415161718</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：上述代码中在函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p>
<h2 id="4-27-extern-C-的作用？"><a href="#4-27-extern-C-的作用？" class="headerlink" title="4.27 extern C 的作用？"></a>4.27 extern C 的作用？</h2><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 extern “C” 指出任意非 C++ 函数所用的语言。<br>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    int strcmp(const char*, const char*);</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-28-sizeof-1-x3D-x3D-1-在-C-和-C-中分别是什么结果？"><a href="#4-28-sizeof-1-x3D-x3D-1-在-C-和-C-中分别是什么结果？" class="headerlink" title="4.28 sizeof(1&#x3D;&#x3D;1) 在 C 和 C++ 中分别是什么结果？"></a>4.28 sizeof(1&#x3D;&#x3D;1) 在 C 和 C++ 中分别是什么结果？</h2><p>C 语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(1==1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line">4</span><br><span class="line">*/</span><br><span class="line">12345678910</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++ 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; sizeof(1==1) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">*/</span><br><span class="line">1234567891011</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-29-memcpy-函数的底层原理？"><a href="#4-29-memcpy-函数的底层原理？" class="headerlink" title="4.29 memcpy 函数的底层原理？"></a>4.29 memcpy 函数的底层原理？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *dst, const void *src, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    char *psrc;</span><br><span class="line">    char *pdst;</span><br><span class="line"></span><br><span class="line">    if (NULL == dst || NULL == src)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((src &lt; dst) &amp;&amp; (char *)src + size &gt; (char *)dst) // 出现地址重叠的情况，自后向前拷贝</span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (char *)src + size - 1;</span><br><span class="line">        pdst = (char *)dst + size - 1;</span><br><span class="line">        while (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (char *)src;</span><br><span class="line">        pdst = (char *)dst;</span><br><span class="line">        while (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dst;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-30-strcpy-函数有什么缺陷？"><a href="#4-30-strcpy-函数有什么缺陷？" class="headerlink" title="4.30 strcpy 函数有什么缺陷？"></a>4.30 strcpy 函数有什么缺陷？</h2><p>strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var = 0x11112222;</span><br><span class="line">    char arr[10];</span><br><span class="line">    cout &lt;&lt; &quot;Address : var &quot; &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Address : arr &quot; &lt;&lt; &amp;arr &lt;&lt; endl;</span><br><span class="line">    strcpy(arr, &quot;hello world!&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;var:&quot; &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; // 将变量 var 以 16 进制输出</span><br><span class="line">    cout &lt;&lt; &quot;arr:&quot; &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Address : var 0x23fe4c</span><br><span class="line">Address : arr 0x23fe42</span><br><span class="line">var:11002164</span><br><span class="line">arr:hello world!</span><br><span class="line">*/</span><br><span class="line">12345678910111213141516171819202122</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：从上述代码中可以看出，变量 var 的后六位被字符串 “hello world!” 的 “d!\0” 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br><strong>原因</strong>：变量 arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var 在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var 的内存空间，导致 var的后六位被覆盖。</p>
<h2 id="4-31-auto-类型推导的原理"><a href="#4-31-auto-类型推导的原理" class="headerlink" title="4.31 auto 类型推导的原理"></a>4.31 auto 类型推导的原理</h2><p><strong>auto 类型推导的原理：</strong></p>
<p>编译器根据初始值来推算变量的类型，要求用 auto 定义变量时必须有初始值。编译器推断出来的 auto 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p>
<h1 id="5-类相关"><a href="#5-类相关" class="headerlink" title="5. 类相关"></a>5. 类相关</h1><h2 id="5-1-什么是虚函数？什么是纯虚函数？"><a href="#5-1-什么是虚函数？什么是纯虚函数？" class="headerlink" title="5.1 什么是虚函数？什么是纯虚函数？"></a>5.1 什么是虚函数？什么是纯虚函数？</h2><p><strong>虚函数</strong>：被 virtual 关键字修饰的成员函数，就是虚函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void v_fun() // 虚函数</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A::v_fun()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void v_fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B::v_fun()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A *p = new B();</span><br><span class="line">    p-&gt;v_fun(); // B::v_fun()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>纯虚函数：</strong></p>
<ul>
<li>纯虚函数在类中声明时，加上 &#x3D;0；</li>
<li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li>
<li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li>
</ul>
<h2 id="5-2-虚函数和纯虚函数的区别？"><a href="#5-2-虚函数和纯虚函数的区别？" class="headerlink" title="5.2 虚函数和纯虚函数的区别？"></a>5.2 虚函数和纯虚函数的区别？</h2><ul>
<li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）</li>
<li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 &#x3D;0;</li>
<li>虚函数必须实现，否则编译器会报错；</li>
<li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ul>
<h2 id="5-3-虚函数的实现机制"><a href="#5-3-虚函数的实现机制" class="headerlink" title="5.3 虚函数的实现机制"></a>5.3 虚函数的实现机制</h2><p><strong>实现机制</strong>：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数</p>
<p><strong>虚函数表相关知识点：</strong></p>
<ul>
<li>虚函数表存放的内容：类的虚函数的地址。</li>
<li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li>
<li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li>
</ul>
<p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p>
<p><strong>实例：</strong></p>
<p>无虚函数覆盖的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p = new Derive();</span><br><span class="line">    p-&gt;B_fun1(); // Base::B_fun1()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基类和派生类的继承关系：<br><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h221ow3ofzj304x0f43z2.jpg" alt="在这里插入图片描述"><br>基类的虚函数表：<br><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h221p0lodxj30fj08ngm2.jpg" alt="在这里插入图片描述"><br>派生类的虚函数表：<br><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h221p5aenwj30hr05r0sz.jpg" alt="在这里插入图片描述"><br>主函数中基类的指针 p 指向了派生类的对象，当调用函数 B_fun1() 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p>
<h2 id="5-4-单继承和多继承的虚函数表结构"><a href="#5-4-单继承和多继承的虚函数表结构" class="headerlink" title="5.4 单继承和多继承的虚函数表结构"></a>5.4 单继承和多继承的虚函数表结构</h2><p><strong>编译器处理虚函数表：</strong></p>
<ul>
<li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li>
<li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li>
<li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li>
<li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li>
</ul>
<ol>
<li>单继承无虚函数覆盖的情况：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p = new Derive();</span><br><span class="line">    p-&gt;B_fun1(); // Base::B_fun1()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基类和派生类的继承关系：<br><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h221qttjuhj304d0etwf1.jpg" alt="在这里插入图片描述"><br>基类的虚函数表：<br><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h221qz3oa5j30fe08haai.jpg" alt="在这里插入图片描述"><br>派生类的虚函数表：<br><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h221r2atmvj30hl05ht8z.jpg" alt="在这里插入图片描述"><br>\2. 单继承有虚函数覆盖的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p = new Derive();</span><br><span class="line">    p-&gt;fun1(); // Derive::fun1()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>派生类的虚函数表：<br><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h221r701v2j30hq06bt95.jpg" alt="在这里插入图片描述"><br>\3. 多继承无虚函数覆盖的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B1_fun1() &#123; cout &lt;&lt; &quot;Base1::B1_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B2_fun1() &#123; cout &lt;&lt; &quot;Base2::B2_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B3_fun1() &#123; cout &lt;&lt; &quot;Base3::B3_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base1, public Base2, public Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Base1 *p = new Derive();</span><br><span class="line">    p-&gt;B1_fun1(); // Base1::B1_fun1()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基类和派生类的关系：<br><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h221rd9blvj30i80epjsw.jpg" alt="在这里插入图片描述"><br>派生类的虚函数表：（基类的顺序和声明的顺序一致）<br><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h221ripqx6j30n206d75f.jpg" alt="在这里插入图片描述"><br>\4. 多继承有虚函数覆盖的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Base1::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Base2::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Base3::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base1, public Base2, public Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Base1 *p1 = new Derive();</span><br><span class="line">    Base2 *p2 = new Derive();</span><br><span class="line">    Base3 *p3 = new Derive();</span><br><span class="line">    p1-&gt;fun1(); // Derive::fun1()</span><br><span class="line">    p2-&gt;fun1(); // Derive::fun1()</span><br><span class="line">    p3-&gt;fun1(); // Derive::fun1()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基类和派生类的关系：<br><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h221ro7rhyj30ib0f3404.jpg" alt="在这里插入图片描述"><br>派生类的虚函数表：<br><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h221rrxmqvj30mz07hgn0.jpg" alt="在这里插入图片描述"></p>
<h1 id="6-语言特性相关"><a href="#6-语言特性相关" class="headerlink" title="6. 语言特性相关"></a>6. 语言特性相关</h1><h2 id="6-1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"><a href="#6-1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？" class="headerlink" title="6.1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"></a>6.1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</h2><p>左值：指表达式结束后依然存在的持久对象。</p>
<p>右值：表达式结束就不再存在的临时对象。</p>
<p>左值和右值的区别：左值持久，右值短暂</p>
<p>右值引用和左值引用的区别：</p>
<ul>
<li>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</li>
<li>右值引用必须绑定到右值的引用，通过 <strong>&amp;&amp;</strong> 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</li>
</ul>
<p><strong>std::move</strong> 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun1(int&amp; tmp) </span><br><span class="line">&#123; </span><br><span class="line">  cout &lt;&lt; &quot;fun1(int&amp; tmp):&quot; &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void fun2(int&amp;&amp; tmp) </span><br><span class="line">&#123; </span><br><span class="line">  cout &lt;&lt; &quot;fun2(int&amp;&amp; tmp)&quot; &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">  int var = 11; </span><br><span class="line">  fun1(12); // error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span><br><span class="line">  fun1(var);</span><br><span class="line">  fun2(1); </span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-2-std-move-函数的实现原理"><a href="#6-2-std-move-函数的实现原理" class="headerlink" title="6.2 std::move() 函数的实现原理"></a>6.2 std::move() 函数的实现原理</h2><p><strong>std::move()</strong> 函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：引用折叠原理</p>
<ul>
<li>右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。</li>
<li>左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。</li>
</ul>
<p>小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。</p>
<p><strong>remove_reference</strong> 具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//原始的，最通用的版本</span><br><span class="line">template &lt;typename T&gt; struct remove_reference&#123;</span><br><span class="line">    typedef T type;  //定义 T 的类型别名为 type</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//部分版本特例化，将用于左值引用和右值引用</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; //左值引用</span><br><span class="line">&#123; typedef T type; &#125;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; //右值引用</span><br><span class="line">&#123; typedef T type; &#125;   </span><br><span class="line">  </span><br><span class="line">//举例如下,下列定义的a、b、c三个变量都是int类型</span><br><span class="line">int i;</span><br><span class="line">remove_refrence&lt;decltype(42)&gt;::type a;             //使用原版本，</span><br><span class="line">remove_refrence&lt;decltype(i)&gt;::type  b;             //左值引用特例版本</span><br><span class="line">remove_refrence&lt;decltype(std::move(i))&gt;::type  b;  //右值引用特例版本 </span><br><span class="line">1234567891011121314151617</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int var = 10; </span><br><span class="line"></span><br><span class="line">转化过程：</span><br><span class="line">1. std::move(var) =&gt; std::move(int&amp;&amp; &amp;) =&gt; 折叠后 std::move(int&amp;)</span><br><span class="line"></span><br><span class="line">2. 此时：T 的类型为 int&amp;，typename remove_reference&lt;T&gt;::type 为 int，这里使用 remove_reference 的左值引用的特例化版本</span><br><span class="line"></span><br><span class="line">3. 通过 static_cast 将 int&amp; 强制转换为 int&amp;&amp;</span><br><span class="line"></span><br><span class="line">整个std::move被实例化如下</span><br><span class="line">string&amp;&amp; move(int&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    return static_cast&lt;int&amp;&amp;&gt;(t); </span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：<br>std::move() 实现原理：</p>
<ul>
<li>利用引用折叠原理将右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp;<br>变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li>
<li>然后通过 remove_refrence 移除引用，得到具体的类型 T；</li>
<li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp; 右值引用。</li>
</ul>
<h2 id="6-3-什么是指针？指针的大小及用法？"><a href="#6-3-什么是指针？指针的大小及用法？" class="headerlink" title="6.3 什么是指针？指针的大小及用法？"></a>6.3 什么是指针？指针的大小及用法？</h2><p><strong>指针</strong>： 指向另外一种类型的复合类型。<br><strong>指针的大小</strong>： 在 64 位计算机中，指针占 8 个字节空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p = nullptr;</span><br><span class="line">    cout &lt;&lt; sizeof(p) &lt;&lt; endl; // 8</span><br><span class="line"></span><br><span class="line">    char *p1 = nullptr;</span><br><span class="line">    cout &lt;&lt; sizeof(p1) &lt;&lt; endl; // 8</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针的用法：</p>
<ol>
<li>指向普通对象的指针</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A *p = new A();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>指向常量对象的指针：常量指针</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const int c_var = 10;</span><br><span class="line">    const int * p = &amp;c_var;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>指向函数的指针：函数指针</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int (*fun_p)(int, int);</span><br><span class="line">    fun_p = add;</span><br><span class="line">    cout &lt;&lt; fun_p(1, 6) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>特别注意：定义指向成员函数的指针时，要标明指针所属的类。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var1, var2; </span><br><span class="line">    int add()&#123;</span><br><span class="line">        return var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A ex;</span><br><span class="line">    ex.var1 = 3;</span><br><span class="line">    ex.var2 = 4;</span><br><span class="line">    int *p = &amp;ex.var1; // 指向对象成员变量的指针</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int (A::*fun_p)();</span><br><span class="line">    fun_p = A::add; // 指向对象成员函数的指针 fun_p</span><br><span class="line">    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>this 指针：指向类的当前对象的指针常量。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_name(string tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    void set_age(int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    void set_sex(int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;sex = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Sex: &quot; &lt;&lt; this-&gt;sex &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A *p = new A();</span><br><span class="line">    p-&gt;set_name(&quot;Alice&quot;);</span><br><span class="line">    p-&gt;set_age(16);</span><br><span class="line">    p-&gt;set_sex(1);</span><br><span class="line">    p-&gt;show();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>什么是野指针和悬空指针？<br>悬空指针：</li>
</ol>
<p>若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *p = malloc(size);</span><br><span class="line">free(p); </span><br><span class="line">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span><br><span class="line">123</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>野指针：</p>
<p>“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p; </span><br><span class="line">// 此时 p 是“野指针”。</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-5-C-11-nullptr-比-NULL-优势"><a href="#6-5-C-11-nullptr-比-NULL-优势" class="headerlink" title="6.5 C++ 11 nullptr 比 NULL 优势"></a>6.5 C++ 11 nullptr 比 NULL 优势</h2><ul>
<li>NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 中，即 #define NULL 0。</li>
<li>nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</li>
</ul>
<p>nullptr 的优势：</p>
<ol>
<li>有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。</li>
<li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char const *p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;fun(char const *p)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int tmp)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;fun(int tmp)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    fun(nullptr); // fun(char const *p)</span><br><span class="line">    /*</span><br><span class="line">    fun(NULL); // error: call of overloaded &#x27;fun(NULL)&#x27; is ambiguous</span><br><span class="line">    */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-6-指针和引用的区别？"><a href="#6-6-指针和引用的区别？" class="headerlink" title="6.6 指针和引用的区别？"></a>6.6 指针和引用的区别？</h2><ul>
<li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</li>
<li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</li>
<li>指针可以为空，但是引用必须绑定对象。（是否可为空）</li>
<li>指针可以有多级，但是引用只能一级。（是否能为多级）</li>
</ul>
<h2 id="6-7-常量指针和指针常量的区别"><a href="#6-7-常量指针和指针常量的区别" class="headerlink" title="6.7 常量指针和指针常量的区别"></a>6.7 常量指针和指针常量的区别</h2><p><strong>常量指针：</strong><br>常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br><strong>特点</strong>：const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int * p;</span><br><span class="line">int const * p;</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int c_var = 8;</span><br><span class="line">    const int *p = &amp;c_var; </span><br><span class="line">    *p = 6;            // error: assignment of read-only location &#x27;* p&#x27;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int c_var1 = 8;</span><br><span class="line">    const int c_var2 = 8;</span><br><span class="line">    const int *p = &amp;c_var1; </span><br><span class="line">    p = &amp;c_var2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针常量：<br>指针常量的本质上是个常量，只不过这个常量的值是一个指针。<br>特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int var;</span><br><span class="line">int * const c_p = &amp;var; </span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var, var1;</span><br><span class="line">    int * const c_p = &amp;var;</span><br><span class="line">    c_p = &amp;var1; // error: assignment of read-only variable &#x27;c_p&#x27;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意 2：指针的内容可以改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var = 3;</span><br><span class="line">    int * const c_p = &amp;var;</span><br><span class="line">    *c_p = 12; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-8-函数指针和指针函数的区别"><a href="#6-8-函数指针和指针函数的区别" class="headerlink" title="6.8 函数指针和指针函数的区别"></a>6.8 函数指针和指针函数的区别</h2><p><strong>指针函数：</strong><br>指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Type</span><br><span class="line">&#123;</span><br><span class="line">  int var1;</span><br><span class="line">  int var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Type * fun(int tmp1, int tmp2)&#123;</span><br><span class="line">    Type * t = new Type();</span><br><span class="line">    t-&gt;var1 = tmp1;</span><br><span class="line">    t-&gt;var2 = tmp2;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Type *p = fun(5, 6);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>函数指针：</strong><br>函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int fun1(int tmp1, int tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  return tmp1 * tmp2;</span><br><span class="line">&#125;</span><br><span class="line">int fun2(int tmp1, int tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  return tmp1 / tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int (*fun)(int x, int y); </span><br><span class="line">  fun = fun1;</span><br><span class="line">  cout &lt;&lt; fun(15, 5) &lt;&lt; endl; </span><br><span class="line">  fun = fun2;</span><br><span class="line">  cout &lt;&lt; fun(15, 5) &lt;&lt; endl; </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line">75</span><br><span class="line">3</span><br><span class="line">*/</span><br><span class="line">12345678910111213141516171819202122232425</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>函数指针和指针函数的区别：</strong></p>
<ul>
<li>本质不同<br>1.指针函数本质是一个函数，其返回值为指针。<br>2.函数指针本质是一个指针变量，其指向一个函数。</li>
<li>定义形式不同<br>1.指针函数：int* fun(int tmp1, int tmp2); ，这里* 表示函数的返回值类型是指针类型。<br>2.函数指针：int (<em>fun)(int tmp1, int tmp2);，这里</em> 表示变量本身是指针类型。</li>
<li>用法不同</li>
</ul>
<h2 id="6-9-强制类型转换有哪几种？"><a href="#6-9-强制类型转换有哪几种？" class="headerlink" title="6.9 强制类型转换有哪几种？"></a>6.9 强制类型转换有哪几种？</h2><ul>
<li><strong>static_cast</strong>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。<br>1.用于基本数据类型的转换。<br>2.用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。<br>3.可以将空指针转化成目标类型的空指针。<br>4.可以将任何类型的表达式转化成 void 类型。</li>
<li><strong>const_cast</strong>：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</li>
<li><strong>reinterpret_cast</strong>：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</li>
<li><strong>dynamic_cast</strong>：<br>1.其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。<br>2.只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。<br>3.在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p1 = new Derive();</span><br><span class="line">    Derive *p2 = new Derive();</span><br><span class="line"></span><br><span class="line">    //向上类型转换</span><br><span class="line">    p1 = dynamic_cast&lt;Base *&gt;(p2);</span><br><span class="line">    if (p1 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; //输出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p1 = new Derive();</span><br><span class="line">    Base *p2 = new Base();</span><br><span class="line">    Derive *p3 = new Derive();</span><br><span class="line"></span><br><span class="line">    //转换成功</span><br><span class="line">    p3 = dynamic_cast&lt;Derive *&gt;(p1);</span><br><span class="line">    if (p3 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; // 输出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //转换失败</span><br><span class="line">    p3 = dynamic_cast&lt;Derive *&gt;(p2);</span><br><span class="line">    if (p3 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; // 输出</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？"><a href="#6-10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？" class="headerlink" title="6.10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？"></a>6.10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</h2><p>需要重载操作符 &#x3D;&#x3D; 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</p>
<p>利用运算符重载来实现结构体对象的比较：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int val;</span><br><span class="line">    A(char c_tmp, int tmp) : c(c_tmp), val(tmp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend bool operator==(const A &amp;tmp1, const A &amp;tmp2); //  友元运算符重载函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator==(const A &amp;tmp1, const A &amp;tmp2)</span><br><span class="line">&#123;</span><br><span class="line">    return (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A ex1(&#x27;a&#x27;, 90), ex2(&#x27;b&#x27;, 80);</span><br><span class="line">    if (ex1 == ex2)</span><br><span class="line">        cout &lt;&lt; &quot;ex1 == ex2&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;ex1 != ex2&quot; &lt;&lt; endl; // 输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-11-参数传递时，值传递、引用传递、指针传递的区别？"><a href="#6-11-参数传递时，值传递、引用传递、指针传递的区别？" class="headerlink" title="6.11 参数传递时，值传递、引用传递、指针传递的区别？"></a>6.11 参数传递时，值传递、引用传递、指针传递的区别？</h2><p>参数传递的三种方式：</p>
<ul>
<li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li>
<li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li>
<li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun1(int tmp)&#123; // 值传递</span><br><span class="line">    cout &lt;&lt; &amp;tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun2(int * tmp)&#123; // 指针传递</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun3(int &amp;tmp)&#123; // 引用传递</span><br><span class="line">    cout &lt;&lt; &amp;tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int var = 5;</span><br><span class="line">    cout &lt;&lt; &quot;var 在主函数中的地址：&quot; &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;var 值传递时的地址：&quot;;</span><br><span class="line">    fun1(var);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;var 指针传递时的地址：&quot;;</span><br><span class="line">    fun2(&amp;var);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;var 引用传递时的地址：&quot;;</span><br><span class="line">    fun3(var);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line">var 在主函数中的地址：0x23fe4c</span><br><span class="line">var 值传递时的地址：0x23fe20</span><br><span class="line">var 指针传递时的地址：0x23fe4c</span><br><span class="line">var 引用传递时的地址：0x23fe4c</span><br><span class="line">*/</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。</p>
<h2 id="6-12-什么是模板？如何实现？"><a href="#6-12-什么是模板？如何实现？" class="headerlink" title="6.12 什么是模板？如何实现？"></a>6.12 什么是模板？如何实现？</h2><p><strong>模板</strong>：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br><strong>实现方式</strong>：模板定义以关键字 <strong>template</strong> 开始，后跟一个模板参数列表。</p>
<ul>
<li>模板参数列表不能为空；</li>
<li>模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U, ...&gt;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p>
<ul>
<li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li>
<li>函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T add_fun(const T &amp; tmp1, const T &amp; tmp2)&#123;</span><br><span class="line">    return tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int var1, var2;</span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    cout &lt;&lt; add_fun(var1, var2);</span><br><span class="line"></span><br><span class="line">    double var3, var4;</span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    cout &lt;&lt; add_fun(var3, var4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Complex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //构造函数</span><br><span class="line">    Complex(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a = a;</span><br><span class="line">        this-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算符重载</span><br><span class="line">    Complex&lt;T&gt; operator+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex&lt;T&gt; tmp(this-&gt;a + c.a, this-&gt;b + c.b);</span><br><span class="line">        cout &lt;&lt; tmp.a &lt;&lt; &quot; &quot; &lt;&lt; tmp.b &lt;&lt; endl;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Complex&lt;int&gt; a(10, 20);</span><br><span class="line">    Complex&lt;int&gt; b(20, 30);</span><br><span class="line">    Complex&lt;int&gt; c = a + b;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-13-函数模板和类模板的区别？"><a href="#6-13-函数模板和类模板的区别？" class="headerlink" title="6.13 函数模板和类模板的区别？"></a>6.13 函数模板和类模板的区别？</h2><ul>
<li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li>
<li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li>
<li>默认参数：类模板在模板参数列表中可以有默认参数。</li>
<li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li>
<li>调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。<br>函数模板调用方式举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T add_fun(const T &amp; tmp1, const T &amp; tmp2)&#123;</span><br><span class="line">    return tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int var1, var2;</span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    cout &lt;&lt; add_fun&lt;int&gt;(var1, var2); // 显式调用</span><br><span class="line"></span><br><span class="line">    double var3, var4;</span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    cout &lt;&lt; add_fun(var3, var4); // 隐式调用</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-14-什么是可变参数模板？"><a href="#6-14-什么是可变参数模板？" class="headerlink" title="6.14 什么是可变参数模板？"></a>6.14 什么是可变参数模板？</h2><p>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p>
<ul>
<li>模板参数包：表示零个或多个模板参数；</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
<p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename... Args&gt; // Args 是模板参数包</span><br><span class="line">void foo(const T &amp;t, const Args&amp;... rest); // 可变参数模板，rest 是函数参数包</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void print_fun(const T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl; // 最后一个元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void print_fun(const T &amp;t, const Args &amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">    print_fun(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    print_fun(&quot;Hello&quot;, &quot;wolrd&quot;, &quot;!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*运行结果：</span><br><span class="line">Hello wolrd !</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">1234567891011121314151617181920212223242526</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。</p>
<h2 id="6-15-什么是模板特化？为什么特化？"><a href="#6-15-什么是模板特化？为什么特化？" class="headerlink" title="6.15 什么是模板特化？为什么特化？"></a>6.15 什么是模板特化？为什么特化？</h2><p>模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</p>
<p>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p>
<ul>
<li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li>
<li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li>
</ul>
<p>特化分为全特化和偏特化：</p>
<ul>
<li>全特化：模板中的模板参数全部特例化。</li>
<li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li>
</ul>
<p>说明：要区分下函数重载与函数模板特化<br>定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//函数模板</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool compare(T t1, T t2)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;通用版本：&quot;;</span><br><span class="line">    return t1 == t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;&gt; //函数模板特化</span><br><span class="line">bool compare(char *t1, char *t2)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;特化版本：&quot;;</span><br><span class="line">    return strcmp(t1, t2) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char arr1[] = &quot;hello&quot;;</span><br><span class="line">    char arr2[] = &quot;abc&quot;;</span><br><span class="line">    cout &lt;&lt; compare(123, 123) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; compare(arr1, arr2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line">通用版本：1</span><br><span class="line">特化版本：0</span><br><span class="line">*/</span><br><span class="line">123456789101112131415161718192021222324252627282930313233</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-16-include-“-“-和-lt-gt-的区别"><a href="#6-16-include-“-“-和-lt-gt-的区别" class="headerlink" title="6.16 include “ “ 和 &lt;&gt; 的区别"></a>6.16 include “ “ 和 &lt;&gt; 的区别</h2><p><strong>include&lt;文件名&gt;</strong> 和 <strong>#include”文件名”</strong> 的区别:</p>
<ul>
<li>查找文件的位置：include&lt;文件名&gt;在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include”文件名” 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li>
<li>使用习惯：对于标准库中的头文件常用 include&lt;文件名&gt;，对于自己定义的头文件，常用 #include”文件名”</li>
</ul>
<h2 id="6-17-泛型编程如何实现？"><a href="#6-17-泛型编程如何实现？" class="headerlink" title="6.17 泛型编程如何实现？"></a>6.17 泛型编程如何实现？</h2><p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。</p>
<p>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p>
<ul>
<li>容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。</li>
<li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li>
<li>模板：可参考本章节中的模板相关问题。</li>
</ul>
<h1 id="7-设计模式"><a href="#7-设计模式" class="headerlink" title="7. 设计模式"></a>7. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a></h1><h2 id="7-1-了解哪些设计模式？"><a href="#7-1-了解哪些设计模式？" class="headerlink" title="7.1 了解哪些设计模式？"></a>7.1 了解哪些设计模式？</h2><p>《大话设计模式》一书中提到 24 种设计模式，这 24 种设计模式没必要面面俱到，但一定要深入了解其中的几种，最好结合自己在实际开发过程中的例子进行深入的了解。</p>
<p>设计模式有 6 大设计原则：</p>
<ul>
<li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。</li>
<li>开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li>
<li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li>
<li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。</li>
<li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li>
<li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li>
</ul>
<p>设计模式分为三类：</p>
<ul>
<li>创造型模式：单例模式、工厂模式、建造者模式、原型模式</li>
<li>结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式</li>
<li>行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</li>
</ul>
<p>下面介绍常见的几种设计模式：</p>
<ul>
<li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式<br>1.简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。<br>2.工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。<br>3.抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li>
<li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。</li>
<li>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成派生类更为灵活。</li>
</ul>
<h2 id="7-2-什么是单例模式？如何实现？应用场景？"><a href="#7-2-什么是单例模式？如何实现？应用场景？" class="headerlink" title="7.2 什么是单例模式？如何实现？应用场景？"></a>7.2 什么是单例模式？如何实现？应用场景？</h2><p><strong>单例模式</strong>：保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。<br><strong>应用场景</strong>：</p>
<ul>
<li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li>
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li>
</ul>
<p><strong>实现方式</strong>：<br>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</p>
<ul>
<li><strong>默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的</strong>，这样禁止在类的外部创建该对象；</li>
<li>全局访问点也要定义成<strong>静态类型的成员函数</strong>，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li>
</ul>
<p>不安全的实现方式：</p>
<p>原因：考虑当两个线程同时调用 getInstance 方法，并且同时检测到 instance 是 NULL，两个线程会同时实例化对象，不符合单例模式的要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    static Singleton * instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    Singleton(const Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; operator=(const Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance()&#123;</span><br><span class="line">        if(instance == NULL)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = NULL;</span><br><span class="line">123456789101112131415</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>分类：</strong></p>
<ul>
<li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li>
<li>饿汉模式：类定义的时候就实例化。</li>
</ul>
<p>线程安全的懒汉模式实现：<br>方法：<strong>加锁</strong><br>存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    static pthread_mutex_t mutex;</span><br><span class="line">    static Singleton * instance;</span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        pthread_mutex_init(&amp;mutex, NULL); </span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(const Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; operator=(const Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance()&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        if(instance == NULL)&#123;            </span><br><span class="line">            instance = new Singleton();            </span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = NULL;</span><br><span class="line">pthread_mutex_t Singleton::mutex;</span><br><span class="line">123456789101112131415161718192021</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法：<strong>内部静态变量</strong>，在全局访问点 getInstance 中定义静态实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    static Singleton* instance;</span><br><span class="line">    Singleton(const Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; operator=(const Singleton&amp; temp)&#123;&#125;</span><br><span class="line">protected:</span><br><span class="line">	 Singleton()&#123;&#125; </span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance()&#123; </span><br><span class="line">        return instance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = new Singleton();</span><br><span class="line">12345678910111213</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-3-什么是工厂模式？如何实现？应用场景？"><a href="#7-3-什么是工厂模式？如何实现？应用场景？" class="headerlink" title="7.3 什么是工厂模式？如何实现？应用场景？"></a>7.3 什么是工厂模式？如何实现？应用场景？</h2><p>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式</p>
<ul>
<li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li>
<li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li>
<li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li>
</ul>
<ol>
<li>简单工厂模式<br>主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li>
</ol>
<p><strong>应用场景：</strong></p>
<ul>
<li>适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如：计算器中对于同样的输入，执行不同的操作：加、减、乘、除。<br><strong>实现方式：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// Here is the product class</span><br><span class="line">class Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var1, var2;</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double res = 0;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Here is the Factory class</span><br><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static Operation *CreateProduct(char op)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (op)</span><br><span class="line">        &#123;</span><br><span class="line">        case &#x27;+&#x27;:</span><br><span class="line">            return new Add_Operation();</span><br><span class="line"></span><br><span class="line">        case &#x27;-&#x27;:</span><br><span class="line">            return new Sub_Operation();</span><br><span class="line"></span><br><span class="line">        case &#x27;*&#x27;:</span><br><span class="line">            return new Mul_Operation();</span><br><span class="line"></span><br><span class="line">        case &#x27;/&#x27;:</span><br><span class="line">            return new Div_Operation();</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return new Add_Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Operation *p = Factory::CreateProduct(&#x27;+&#x27;);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p = Factory::CreateProduct(&#x27;*&#x27;);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>工厂方法模式</li>
</ol>
<p>修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p>
<p><strong>应用场景：</strong></p>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>一个类通过其派生类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，派生类对象将覆盖父类对象，从而使得系统更容易扩展。<br>将创建对象的任务委托给多个工厂派生类中的某一个，客户端在使用时可以无须关心是哪一个工厂派生类创建产品派生类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p><strong>实现方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// Here is the product class</span><br><span class="line">class Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var1, var2;</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double res = 0;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Operation : public Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual Operation *CreateProduct() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation *CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Add_Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation *CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Sub_Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation *CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Mul_Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation *CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Div_Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = new Add_Factory();</span><br><span class="line">    Operation *p_pro = p_fac-&gt;CreateProduct();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line"></span><br><span class="line"> - List item</span><br><span class="line"></span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Mul_Factory *p_fac1 = new Mul_Factory();</span><br><span class="line">    Operation *p_pro1 = p_fac1-&gt;CreateProduct();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>抽象工厂模式</li>
</ol>
<p>定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的 产品等级结构。</li>
</ul>
<p><strong>实现方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// Here is the product class</span><br><span class="line">class Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var1, var2;</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double res = 0;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Operation_Pos : public Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Operation_Pos : public Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Operation_Pos : public Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Operation_Pos : public Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*********************************************************************************/</span><br><span class="line">class Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int var1, var2;</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double res = 0;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Operation_Neg : public Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return -(var1 + var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Operation_Neg : public Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return -(var1 - var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Operation_Neg : public Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return -(var1 * var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Operation_Neg : public Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return -(var1 / var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*****************************************************************************************************/</span><br><span class="line"></span><br><span class="line">// Here is the Factory class</span><br><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual Operation_Pos *CreateProduct_Pos() = 0;</span><br><span class="line">    virtual Operation_Neg *CreateProduct_Neg() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Add_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation_Pos *CreateProduct_Pos()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Add_Operation_Pos();</span><br><span class="line">    &#125;</span><br><span class="line">    Operation_Neg *CreateProduct_Neg()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Add_Operation_Neg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation_Pos *CreateProduct_Pos()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Sub_Operation_Pos();</span><br><span class="line">    &#125;</span><br><span class="line">    Operation_Neg *CreateProduct_Neg()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Sub_Operation_Neg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mul_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation_Pos *CreateProduct_Pos()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Mul_Operation_Pos();</span><br><span class="line">    &#125;</span><br><span class="line">    Operation_Neg *CreateProduct_Neg()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Mul_Operation_Neg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Div_Factory : public Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Operation_Pos *CreateProduct_Pos()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Div_Operation_Pos();</span><br><span class="line">    &#125;</span><br><span class="line">    Operation_Neg *CreateProduct_Neg()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Div_Operation_Neg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = new Add_Factory();</span><br><span class="line">    Operation_Pos *p_pro = p_fac-&gt;CreateProduct_Pos();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Add_Factory *p_fac1 = new Add_Factory();</span><br><span class="line">    Operation_Neg *p_pro1 = p_fac1-&gt;CreateProduct_Neg();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-4-什么是观察者模式？如何实现？应用场景？"><a href="#7-4-什么是观察者模式？如何实现？应用场景？" class="headerlink" title="7.4 什么是观察者模式？如何实现？应用场景？"></a>7.4 什么是观察者模式？如何实现？应用场景？</h2><p><strong>观察者模式</strong>：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p>
<p><strong>观察者模式中存在两种角色：</strong></p>
<ul>
<li><strong>观察者：</strong> 内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li>
<li><strong>被观察者：</strong> 内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li>
<li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li>
</ul>
<p><strong>实现方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Subject;</span><br><span class="line">//观察者 基类 （内部实例化了被观察者的对象sub）</span><br><span class="line">class Observer</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    string name;</span><br><span class="line">    Subject *sub;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Observer(string name, Subject *sub)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name = name;</span><br><span class="line">        this-&gt;sub = sub;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void update() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class StockObserver : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    StockObserver(string name, Subject *sub) : Observer(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void update();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class NBAObserver : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    NBAObserver(string name, Subject *sub) : Observer(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void update();</span><br><span class="line">&#125;;</span><br><span class="line">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span><br><span class="line">class Subject</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    list&lt;Observer *&gt; observers;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    string action; //被观察者对象的状态</span><br><span class="line">    virtual void attach(Observer *) = 0;</span><br><span class="line">    virtual void detach(Observer *) = 0;</span><br><span class="line">    virtual void notify() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Secretary : public Subject</span><br><span class="line">&#123;</span><br><span class="line">    void attach(Observer *observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.push_back(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    void detach(Observer *observer)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.begin();</span><br><span class="line">        while (iter != observers.end())</span><br><span class="line">        &#123;</span><br><span class="line">            if ((*iter) == observer)</span><br><span class="line">            &#123;</span><br><span class="line">                observers.erase(iter);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void notify()</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.begin();</span><br><span class="line">        while (iter != observers.end())</span><br><span class="line">        &#123;</span><br><span class="line">            (*iter)-&gt;update();</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void StockObserver::update()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    if (sub-&gt;action == &quot;梁所长来了!&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;我马上关闭股票，装做很认真工作的样子！&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NBAObserver::update()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    if (sub-&gt;action == &quot;梁所长来了!&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;我马上关闭NBA，装做很认真工作的样子！&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Subject *dwq = new Secretary();</span><br><span class="line">    Observer *xs = new NBAObserver(&quot;xiaoshuai&quot;, dwq);</span><br><span class="line">    Observer *zy = new NBAObserver(&quot;zouyue&quot;, dwq);</span><br><span class="line">    Observer *lm = new StockObserver(&quot;limin&quot;, dwq);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;attach(xs);</span><br><span class="line">    dwq-&gt;attach(zy);</span><br><span class="line">    dwq-&gt;attach(lm);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = &quot;去吃饭了！&quot;;</span><br><span class="line">    dwq-&gt;notify();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    dwq-&gt;action = &quot;梁所长来了!&quot;;</span><br><span class="line">    dwq-&gt;notify();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/yolov5%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/yolov5%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">yolov5原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-25 11:20:48" itemprop="dateCreated datePublished" datetime="2022-04-25T11:20:48+08:00">2022-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-29 16:33:37" itemprop="dateModified" datetime="2022-04-29T16:33:37+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开<br>作者邮箱：<a href="mailto:&#x75;&#110;&#x69;&#x71;&#x75;&#101;&#x5f;&#104;&#97;&#110;&#103;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x75;&#110;&#x69;&#x71;&#x75;&#101;&#x5f;&#104;&#97;&#110;&#103;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h1lswbglnxj30uz0tddnn.jpg"></p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1lxenahgpj31hc0u01kx.jpg"></p>
<h2 id="网络架构与组件"><a href="#网络架构与组件" class="headerlink" title="网络架构与组件"></a>网络架构与组件</h2><p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h1lx3id3a4j31g50ev7kd.jpg"></p>
<p>YOLOv5包括</p>
<ul>
<li>Backbone:Focus,BottleneckCSP,SPP</li>
<li>Head:PANet+Detect(类似于YOLOv3&#x2F;v4 Head)</li>
</ul>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1m07hbenej317e0oqaiu.jpg"></p>
<p>Focus（）模块设计用于减少FLOPS和提高速度，而不是mAP i,输入是[b,c,h,w]会变成[b,c*4,h&#x2F;&#x2F;2,w&#x2F;&#x2F;2],把宽度w和高度h的信息整合到c空间中</p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1m2ie0f4yj30xl0qcgrq.jpg"></p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h1m2nncjdrj31hc0u0wua.jpg"></p>
<p>SPP增加感受野，提取重要的上下文特征，不会导致速度的减小。</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h1m2rvocj3j31hc0u04d1.jpg"></p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h1m399fi6lj31hc0u04dn.jpg"></p>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h1m3ivfrbyj31790qib0t.jpg"></p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1m3muilraj30yd0sjqme.jpg"></p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h1m3qk9b8qj31gp0gwtyc.jpg"></p>
<p><strong>DIOU的适应性更好</strong></p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>DIOU比 IOU和GIOU 有更快的收敛速度</p>
<p>CIOU考虑的因素更多，考虑了：重叠的面积（overlap area），中点距离（central point distance），宽高比（aspect ratio）</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li><p><strong>调整锚框</strong>的大小，位置，宽高比等信息，使模型能够获得更加合理的先验信息。</p>
</li>
<li><p>通过<strong>K-means聚类</strong>的方法对数据集中的目标边框进行重新聚类、并将CIoU损失函数和DIoU_nms应用于YOLOv5算法来提高目标识别效果 </p>
</li>
<li><p><strong>注意力机制和特征融合</strong> ：</p>
</li>
</ul>
<p>为了抑制复杂背景干扰，在其基础上引入空间与通道卷积注意力模型，以增强待检测故障目标的显著度；然后，将原始YOLOv5检测框架neck中的FPN+PAN结构改为BiFPN结构，从而使目标多尺度特征能够有效融合；其次，为了解决待检测目标特征表达能力不足而造成漏检和误检的问题，设计了多尺度与同尺度特征的自适应加权融合模块，以增强检测网络对遮挡情况下故障目标的检测能力。  《基于注意力机制与跨尺度特征融合的YOLOv5输电线路故障检测 》</p>
<ul>
<li><strong>非极大值抑制缺点</strong>：1，NMS仅保留得分最大的预测边界框而丢弃得分小的预测边界框，但得分较小的边界框也同样包含一定的特征信息，直接丢弃相当于没有完全利用全部信息。2，在一些情况下得分最高的预测边界框也不能很好的拟合真实的目标框，直接选用该预测框作为最终预测值具有较高的损失。</li>
<li>使用<strong>Mosaic-8</strong>方法进行数据增强，通过增加一个浅层特征图、调整损失函数，来增强网络对小目标的感知能力；通过修改目标框回归公式，解决训练过程中梯度消失等问题，提升了小目标的检测精度。</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/13/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">python数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-13 20:45:37" itemprop="dateCreated datePublished" datetime="2022-04-13T20:45:37+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-29 20:52:27" itemprop="dateModified" datetime="2022-04-29T20:52:27+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开<br>作者邮箱：<a href="mailto:&#117;&#x6e;&#x69;&#x71;&#x75;&#101;&#95;&#104;&#97;&#x6e;&#103;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#117;&#x6e;&#x69;&#x71;&#x75;&#101;&#95;&#104;&#97;&#x6e;&#103;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<h1 id="python数据结构"><a href="#python数据结构" class="headerlink" title="python数据结构"></a>python数据结构</h1><p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h1dw6ja6saj30kk0feaby.jpg"></p>
<h2 id="1-栈-gt-列表"><a href="#1-栈-gt-列表" class="headerlink" title="1.栈 -&gt; 列表"></a>1.栈 -&gt; 列表</h2><p><img src="https://wx2.sinaimg.cn/mw2000/008qBzMjgy1h0py43kzyij30py0f9jyw.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Stack():</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.items = []</span><br><span class="line">	def push(self,item):</span><br><span class="line">		self.items.append(item)</span><br><span class="line">	def peek(self):</span><br><span class="line">		return self.items[len(self.items)-1]</span><br><span class="line">	def isEmpty(self):</span><br><span class="line">		return self.items == []</span><br><span class="line">	def size(self):</span><br><span class="line">		return len(self.items)</span><br><span class="line">	def pop(self):</span><br><span class="line">		return self.items.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>左括号入栈，右括号与栈顶比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def matchs(open,close):</span><br><span class="line">	opens = &#x27;([&#123;&#x27;</span><br><span class="line">	closes = &#x27;)]&#125;&#x27;</span><br><span class="line">	return opens.index(open) == closes.index(close)</span><br><span class="line">def parChecker(symbolStoring):</span><br><span class="line">	S=Stack()</span><br><span class="line">	for i in symbolStoring:</span><br><span class="line">		if i in &#x27;([&#123;&#x27;:</span><br><span class="line">			S.push(i)</span><br><span class="line">		else:</span><br><span class="line">			if S.isEmpty():</span><br><span class="line">				return False</span><br><span class="line">			top = S.pop()</span><br><span class="line">			if not matchs(top,i):</span><br><span class="line">				return False</span><br><span class="line"></span><br><span class="line">	if S.isEmpty():</span><br><span class="line">		return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print( parChecker(&#x27;(([[(&#123;&#125;)]]))&#123;&#125;&#x27;))</span><br></pre></td></tr></table></figure>

<h4 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h4><p>eg:输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]输出：9。解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>
<p>遇到数字入栈，遇到符号则弹出栈中两个数字进行运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line">    def push(self,item):</span><br><span class="line">        self.items.append(item)</span><br><span class="line">    def pop(self):</span><br><span class="line">        return self.items.pop()</span><br><span class="line">    def size(self):</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def evalRPN(self, tokens: List[str]) -&gt; int:</span><br><span class="line">        mystack = Stack()</span><br><span class="line">        for i in tokens:</span><br><span class="line">            if i in &#x27;+-*/&#x27;:</span><br><span class="line">                a= int(mystack.pop())</span><br><span class="line">                b= int(mystack.pop())</span><br><span class="line">                if i == &#x27;+&#x27;:</span><br><span class="line">                    tmp = b+a</span><br><span class="line">                if i == &#x27;-&#x27;:</span><br><span class="line">                    tmp = b-a</span><br><span class="line">                if i == &#x27;*&#x27;:</span><br><span class="line">                    tmp = b*a</span><br><span class="line">                if i == &#x27;/&#x27;:</span><br><span class="line">                    tmp = b/a</span><br><span class="line">                mystack.push(tmp)</span><br><span class="line">            else:</span><br><span class="line">                mystack.push(i)</span><br><span class="line">        </span><br><span class="line">        return int(mystack.pop())</span><br></pre></td></tr></table></figure>



<h2 id="2-队列-gt-列表"><a href="#2-队列-gt-列表" class="headerlink" title="2.队列 -&gt; 列表"></a>2.队列 -&gt; 列表</h2><p>队列是一种有次序的数据集合，其特征是：新数据项的添加总发生在一端（通常称为“尾rear”）端；而现存数据项的移除总发生在另一端（通常称为“首front”）</p>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h0pot6i03gj30so0m6aka.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Queue:</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.items = []</span><br><span class="line"></span><br><span class="line">	def isEmpty(self):</span><br><span class="line">		return self.items == []</span><br><span class="line"></span><br><span class="line">	def enqueue(self,item):</span><br><span class="line">		self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">	def dequeue(self):</span><br><span class="line">		return self.items.pop()</span><br><span class="line"></span><br><span class="line">	def size(self):</span><br><span class="line">		return len(self.items)</span><br></pre></td></tr></table></figure>

<h3 id="热土豆问题"><a href="#热土豆问题" class="headerlink" title="热土豆问题"></a>热土豆问题</h3><p>队首始终是持有土豆的人，传递了num次后，将队首的人移除，不再入队如此反复，直到队列中剩余1人</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">####热土豆问题###</span><br><span class="line">def hotPotato(namelist,num):</span><br><span class="line">	Q = Queue()</span><br><span class="line">	for name in namelist:</span><br><span class="line">		Q.enqueue(name)</span><br><span class="line"></span><br><span class="line">	while Q.size() &gt; 1:</span><br><span class="line">		for i in range(num):</span><br><span class="line">			tmp = Q.dequeue()</span><br><span class="line">			Q.enqueue(tmp)</span><br><span class="line"></span><br><span class="line">		Q.dequeue()</span><br><span class="line"></span><br><span class="line">	return Q.dequeue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hotPotato([&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;],5))</span><br></pre></td></tr></table></figure>



<h2 id="3-双端队列-gt-列表"><a href="#3-双端队列-gt-列表" class="headerlink" title="3.双端队列 -&gt; 列表"></a>3.双端队列 -&gt; 列表</h2><p>双端队列Deque是一种有次序的数据集，跟队列相似，其两端可以称作“首“”“尾”，但deque数项可从首入也以中数据项既可以从队首加入，也可以从队尾加入；数据项也可以从两端移除。</p>
<p><img src="https://wx2.sinaimg.cn/large/007BSstUgy1h0ptbqcf7kj30g80bldk3.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Deque():</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.items = []</span><br><span class="line"></span><br><span class="line">	def isEmpty(self):</span><br><span class="line">		return self.items == []</span><br><span class="line"></span><br><span class="line">	def addRear(self,item):</span><br><span class="line">		self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">	def addFront(self,item):</span><br><span class="line">		self.items.append(item)</span><br><span class="line"></span><br><span class="line">	def size(self):</span><br><span class="line">		return len(self.items)</span><br><span class="line"></span><br><span class="line">	def removeRear(self):</span><br><span class="line">		return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">	def removeFront(self):</span><br><span class="line">		return self.items.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#####回文#####</span><br><span class="line">def huiwen(lst):</span><br><span class="line">	DQ = Deque()</span><br><span class="line">	for i in lst:</span><br><span class="line">		DQ.addRear(i)</span><br><span class="line">	while DQ.size() &gt; 1:</span><br><span class="line">		if DQ.removeRear() != DQ.removeFront():</span><br><span class="line">			return False</span><br><span class="line"></span><br><span class="line">	return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(huiwen(&#x27;tootoot&#x27;))</span><br></pre></td></tr></table></figure>



<h2 id="4-无序表的链表"><a href="#4-无序表的链表" class="headerlink" title="4.无序表的链表"></a>4.无序表的链表</h2><p>一种数据项按照相对位置存放的数据集</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h0s6naey6jj30v606tq3s.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self,initdata):</span><br><span class="line">        self.data = initdata</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">    def getData(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">    def getNext(self):</span><br><span class="line">        return self.next</span><br><span class="line"></span><br><span class="line">    def setData(self,newdata):</span><br><span class="line">        self.data = newdata</span><br><span class="line"></span><br><span class="line">    def setNext(self,newnext):</span><br><span class="line">        self.next = newnext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UnorderedList:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None	#self.head是Node类型</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        return self.head == None</span><br><span class="line">            </span><br><span class="line">    def add(self,item):</span><br><span class="line">        temp = Node(item)</span><br><span class="line">        temp.setNext(self.head)</span><br><span class="line">        self.head = temp</span><br><span class="line">        </span><br><span class="line">    def length(self):</span><br><span class="line">        current = self.head</span><br><span class="line">        count = 0</span><br><span class="line">        while current != None:</span><br><span class="line">            count = count + 1</span><br><span class="line">            current = current.getNext()</span><br><span class="line"></span><br><span class="line">        return count</span><br><span class="line">        </span><br><span class="line">    def search(self,item):</span><br><span class="line">        current = self.head</span><br><span class="line">        found = False</span><br><span class="line">        while current != None and not found:</span><br><span class="line">            if current.getData() == item:</span><br><span class="line">                found = True</span><br><span class="line">            else:</span><br><span class="line">                current = current.getNext()</span><br><span class="line"></span><br><span class="line">        return found</span><br><span class="line">                </span><br><span class="line">    def remove(self,item):</span><br><span class="line">        current = self.head</span><br><span class="line">        previous = None</span><br><span class="line">        found = False</span><br><span class="line">        while not found:</span><br><span class="line">            if current.getData() == item:</span><br><span class="line">                found = True</span><br><span class="line">            else:</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.getNext()</span><br><span class="line"></span><br><span class="line">        if previous == None:</span><br><span class="line">            self.head = current.getNext()</span><br><span class="line">        else:</span><br><span class="line">            previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure>



<h2 id="5-有序表"><a href="#5-有序表" class="headerlink" title="5.有序表"></a>5.有序表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self,initdata):</span><br><span class="line">        self.data = initdata</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">    def getData(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">    def getNext(self):</span><br><span class="line">        return self.next</span><br><span class="line"></span><br><span class="line">    def setData(self,newdata):</span><br><span class="line">        self.data = newdata</span><br><span class="line"></span><br><span class="line">    def setNext(self,newnext):</span><br><span class="line">        self.next = newnext</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class OrderedList:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None</span><br><span class="line"></span><br><span class="line">    def search(self,item):</span><br><span class="line">        current = self.head</span><br><span class="line">        found = False</span><br><span class="line">        stop = False</span><br><span class="line">        while current != None and not found and not stop:</span><br><span class="line">            if current.getData() == item:</span><br><span class="line">                found = True</span><br><span class="line">            else:</span><br><span class="line">                if current.getData() &gt; item:</span><br><span class="line">                    stop = True</span><br><span class="line">                else:</span><br><span class="line">                    current = current.getNext()</span><br><span class="line"></span><br><span class="line">        return found</span><br><span class="line">        </span><br><span class="line">    def add(self,item):</span><br><span class="line">        current = self.head</span><br><span class="line">        previous = None</span><br><span class="line">        stop = False</span><br><span class="line">        while current != None and not stop:</span><br><span class="line">            if current.getData() &gt; item:</span><br><span class="line">                stop = True</span><br><span class="line">            else:</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.getNext()</span><br><span class="line"></span><br><span class="line">        temp = Node(item)</span><br><span class="line">        if previous == None:</span><br><span class="line">            temp.setNext(self.head)</span><br><span class="line">            self.head = temp</span><br><span class="line">        else:</span><br><span class="line">            temp.setNext(current)</span><br><span class="line">            previous.setNext(temp)       </span><br><span class="line">            </span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        return self.head == None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        current = self.head</span><br><span class="line">        count = 0</span><br><span class="line">        while current != None:</span><br><span class="line">            count = count + 1</span><br><span class="line">            current = current.getNext()</span><br><span class="line"></span><br><span class="line">        return count</span><br><span class="line">        </span><br><span class="line">    def traverse(self):</span><br><span class="line">        current = self.head</span><br><span class="line">        while current != None:</span><br><span class="line">            print(current.getData())</span><br><span class="line">            current = current.getNext()</span><br></pre></td></tr></table></figure>

<h2 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h2><p>递归三定律：</p>
<p>1，递归算法必须有一个基本结束条件（最小规模问题的直接解决）</p>
<p>2，递归算法必须能改变状态向基本结束条件演进（减小问题规模）</p>
<p>3，递归算法必须调用自身（解决减小了规模的相同问题）</p>
<h2 id="7-查找"><a href="#7-查找" class="headerlink" title="7.查找"></a>7.查找</h2><h3 id="顺序查找-o-n"><a href="#顺序查找-o-n" class="headerlink" title="顺序查找:o(n)"></a>顺序查找:o(n)</h3><p>有序表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def orderedSequentialSearch(alist, item):</span><br><span class="line">    pos = 0</span><br><span class="line">    found = False</span><br><span class="line">    stop = False</span><br><span class="line">    while pos &lt; len(alist) and not found and not stop:</span><br><span class="line">        if alist[pos] == item:</span><br><span class="line">            found = True</span><br><span class="line">        else:</span><br><span class="line">            if alist[pos] &gt; item:</span><br><span class="line">                stop = True</span><br><span class="line">            else:</span><br><span class="line">                pos = pos+1</span><br><span class="line"></span><br><span class="line">    return found</span><br><span class="line"></span><br><span class="line">testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(orderedSequentialSearch(testlist, 3))</span><br><span class="line">print(orderedSequentialSearch(testlist, 13))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无序表</p>
<p>def sequentialSearch(alist, item):<br>    pos &#x3D; 0<br>    found &#x3D; False</p>
<pre><code>while pos &lt; len(alist) and not found:
    if alist[pos] == item:
        found = True
    else:
        pos = pos+1

return found

testlist = [1, 2, 32, 8, 17, 19, 42, 13, 0]
print(sequentialSearch(testlist, 3))
print(sequentialSearch(testlist, 13))
</code></pre>
<h3 id="二分查找-o-log-n"><a href="#二分查找-o-log-n" class="headerlink" title="二分查找:o(log n)"></a>二分查找:o(log n)</h3><p>适用的前提：有序表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def binarySearch(alist, item):</span><br><span class="line">    first = 0</span><br><span class="line">    last = len(alist)-1</span><br><span class="line">    found = False</span><br><span class="line"></span><br><span class="line">    while first&lt;=last and not found:</span><br><span class="line">        midpoint = (first + last)//2</span><br><span class="line">        if alist[midpoint] == item:</span><br><span class="line">            found = True</span><br><span class="line">        else:</span><br><span class="line">            if item &lt; alist[midpoint]:</span><br><span class="line">                last = midpoint-1</span><br><span class="line">            else:</span><br><span class="line">                first = midpoint+1</span><br><span class="line"></span><br><span class="line">    return found</span><br><span class="line"></span><br><span class="line">testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(binarySearch(testlist, 3))</span><br><span class="line">print(binarySearch(testlist, 13))</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="散列查找：o-1-gt-字典"><a href="#散列查找：o-1-gt-字典" class="headerlink" title="散列查找：o(1) -&gt; 字典"></a>散列查找：o(1) -&gt; 字典</h3><p>实现从数据项到存储槽名称的转换的，称为散列函数 </p>
<p>有一种常用的散列方法是“求余数”，将数据项除以散列表的大小，得到的余数作为槽号。</p>
<p>​                            <strong>冲突解决方案：</strong> </p>
<p>解决散列的一种方法就是为冲突的数据项再找一个开放的空槽来保存，最简单的就是从冲突的槽开始往后扫描，直到碰到一个空槽 ，如果到散列表尾部还未找到，则从首部接着扫描。</p>
<ul>
<li>线性探测 ：数据项位置+1</li>
<li>跳跃式探测：数据项位置+n。注意的是skip的取值，不能被散列表大小整除，否则会产生周期，造成很多空槽永远无法探测到 </li>
<li>数据项链：将容纳单个数据项的槽扩展为容纳数据项集合（或者对数据项链表的引用）</li>
</ul>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h12br8hsruj30kp0aljsj.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#简单的线性探测</span><br><span class="line">class HashTable:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.size = 11</span><br><span class="line">        self.slots = [None] * self.size</span><br><span class="line">        self.data = [None] * self.size</span><br><span class="line">        </span><br><span class="line">    def put(self,key,data):</span><br><span class="line">      hashvalue = self.hashfunction(key,len(self.slots))</span><br><span class="line"></span><br><span class="line">      if self.slots[hashvalue] == None:</span><br><span class="line">        self.slots[hashvalue] = key</span><br><span class="line">        self.data[hashvalue] = data</span><br><span class="line">      else:</span><br><span class="line">        if self.slots[hashvalue] == key:</span><br><span class="line">          self.data[hashvalue] = data  #replace</span><br><span class="line">        else:</span><br><span class="line">          nextslot = self.rehash(hashvalue,len(self.slots))</span><br><span class="line">          while self.slots[nextslot] != None and \</span><br><span class="line">                          self.slots[nextslot] != key:</span><br><span class="line">            nextslot = self.rehash(nextslot,len(self.slots))</span><br><span class="line"></span><br><span class="line">          if self.slots[nextslot] == None:</span><br><span class="line">            self.slots[nextslot]=key</span><br><span class="line">            self.data[nextslot]=data</span><br><span class="line">          else:</span><br><span class="line">            self.data[nextslot] = data #replace</span><br><span class="line"></span><br><span class="line">    def hashfunction(self,key,size):</span><br><span class="line">         return key%size</span><br><span class="line"></span><br><span class="line">    def rehash(self,oldhash,size):</span><br><span class="line">        return (oldhash+1)%size</span><br><span class="line">        </span><br><span class="line">    def get(self,key):</span><br><span class="line">      startslot = self.hashfunction(key,len(self.slots))</span><br><span class="line"></span><br><span class="line">      data = None</span><br><span class="line">      stop = False</span><br><span class="line">      found = False</span><br><span class="line">      position = startslot</span><br><span class="line">      while self.slots[position] != None and  \</span><br><span class="line">                           not found and not stop:</span><br><span class="line">         if self.slots[position] == key:</span><br><span class="line">           found = True</span><br><span class="line">           data = self.data[position]</span><br><span class="line">         else:</span><br><span class="line">           position=self.rehash(position,len(self.slots))</span><br><span class="line">           if position == startslot:</span><br><span class="line">               stop = True</span><br><span class="line">      return data</span><br><span class="line"></span><br><span class="line">    def __getitem__(self,key):</span><br><span class="line">        return self.get(key)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self,key,data):</span><br><span class="line">        self.put(key,data)</span><br><span class="line">        </span><br><span class="line">H=HashTable()</span><br><span class="line">H[54]=&quot;cat&quot;</span><br><span class="line">H[26]=&quot;dog&quot;</span><br><span class="line">H[93]=&quot;lion&quot;</span><br><span class="line">H[17]=&quot;tiger&quot;</span><br><span class="line">H[77]=&quot;bird&quot;</span><br><span class="line">H[31]=&quot;cow&quot;</span><br><span class="line">H[44]=&quot;goat&quot;</span><br><span class="line">H[55]=&quot;pig&quot;</span><br><span class="line">H[20]=&quot;chicken&quot;</span><br><span class="line">print(H.slots)</span><br><span class="line">print(H.data)</span><br><span class="line"></span><br><span class="line">print(H[20])</span><br><span class="line"></span><br><span class="line">print(H[17])</span><br><span class="line">H[20]=&#x27;duck&#x27;</span><br><span class="line">print(H[20])</span><br><span class="line">print(H[99])</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-排序算法"><a href="#8-排序算法" class="headerlink" title="8.排序算法"></a>8.排序算法</h2><h3 id="冒泡排序-o-n-2"><a href="#冒泡排序-o-n-2" class="headerlink" title="冒泡排序:o(n^2)"></a>冒泡排序:o(n^2)</h3><p>每趟包括了多次两两相邻比较，并将逆序的数据项互换位置，最终能将本趟的最大项就位.</p>
<p>优势：无需任何额外的存储空间开销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(alist):</span><br><span class="line">    for passnum in range(len(alist)-1,0,-1):</span><br><span class="line">        for i in range(passnum):</span><br><span class="line">            if alist[i]&gt;alist[i+1]:</span><br><span class="line">                temp = alist[i]</span><br><span class="line">                alist[i] = alist[i+1]</span><br><span class="line">                alist[i+1] = temp</span><br><span class="line"></span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">bubbleSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<h3 id="选择排序-o-n-2"><a href="#选择排序-o-n-2" class="headerlink" title="选择排序:o(n^2)"></a>选择排序:o(n^2)</h3><p>每趟仅进行1次交换，记录最大项的所在位置，最后再跟本趟最后一项交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def selectionSort(alist):</span><br><span class="line">   for fillslot in range(len(alist)-1,0,-1):</span><br><span class="line">       positionOfMax=0</span><br><span class="line">       for location in range(1,fillslot+1):</span><br><span class="line">           if alist[location]&gt;alist[positionOfMax]:</span><br><span class="line">               positionOfMax = location</span><br><span class="line"></span><br><span class="line">       temp = alist[fillslot]</span><br><span class="line">       alist[fillslot] = alist[positionOfMax]</span><br><span class="line">       alist[positionOfMax] = temp</span><br><span class="line"></span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">selectionSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<h3 id="插入排序-o-n-2"><a href="#插入排序-o-n-2" class="headerlink" title="插入排序:o(n^2)"></a>插入排序:o(n^2)</h3><p>插入排序维持一个已排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表</p>
<p><img src="https://i0.hdslb.com/bfs/album/ab30d1429a1143a2bcc79ee6fa5f7d08f445879e.png"></p>
<p>具体思路：</p>
<p>需要让31插入，先于93比较，93向后挪，再与77比较，77向后挪……以此类推</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h0zzk5cnxxj30ht0ew778.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def insertionSort(alist):</span><br><span class="line">   for index in range(1,len(alist)):</span><br><span class="line"></span><br><span class="line">     currentvalue = alist[index]</span><br><span class="line">     position = index</span><br><span class="line"></span><br><span class="line">     while position&gt;0 and alist[position-1]&gt;currentvalue:</span><br><span class="line">         alist[position]=alist[position-1]</span><br><span class="line">         position = position-1</span><br><span class="line"></span><br><span class="line">     alist[position]=currentvalue</span><br><span class="line"></span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">insertionSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<h3 id="谢尔排序-o-n-1-5"><a href="#谢尔排序-o-n-1-5" class="headerlink" title="谢尔排序:o(n^1.5)"></a>谢尔排序:o(n^1.5)</h3><p>谢尔排序以插入排序作为基础，对无序表进行“间隔”划分子列表，每个子列表都执行插入排序</p>
<p>子列表的间隔一般从n&#x2F;2开始，每趟倍增：n&#x2F;4, n&#x2F;8……直到1</p>
<p>eg:间隔为3的子列表，子列表分别插入排序后的整体状况更接近有序。（每一行黑色的为一个子列表）</p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h0zzw5khhsj30ch070402.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(alist):</span><br><span class="line">    sublistcount = len(alist)//2</span><br><span class="line">    while sublistcount &gt; 0:</span><br><span class="line"></span><br><span class="line">      for startposition in range(sublistcount):</span><br><span class="line">        gapInsertionSort(alist,startposition,sublistcount)</span><br><span class="line"></span><br><span class="line">      print(&quot;After increments of size&quot;,sublistcount,</span><br><span class="line">                                   &quot;The list is&quot;,alist)</span><br><span class="line"></span><br><span class="line">      sublistcount = sublistcount // 2</span><br><span class="line"></span><br><span class="line">def gapInsertionSort(alist,start,gap):</span><br><span class="line">    for i in range(start+gap,len(alist),gap):</span><br><span class="line"></span><br><span class="line">        currentvalue = alist[i]</span><br><span class="line">        position = i</span><br><span class="line"></span><br><span class="line">        while position&gt;=gap and alist[position-gap]&gt;currentvalue:</span><br><span class="line">            alist[position]=alist[position-gap] </span><br><span class="line">            position = position-gap</span><br><span class="line"></span><br><span class="line">        alist[position]=currentvalue</span><br><span class="line">        </span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">shellSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<h3 id="归并排序-o-n-log-n"><a href="#归并排序-o-n-log-n" class="headerlink" title="归并排序:o(n*log n)"></a>归并排序:o(n*log n)</h3><p>归并排序是递归算法，思路是将数据表持续分裂为两半，对两半分别进行归并排序 </p>
<ul>
<li>递归的基本结束条件是：数据表仅有1个数据项，自然是排好序的；</li>
<li>缩小规模：将数据表分裂为相等的两半，规模减为原来的二分之一</li>
<li>调用自身：将两半分别调用自身排序，然后将分别排好序的两半进行归并，得到排好序的数据表</li>
</ul>
<p>缺点：使用了额外1倍的存储空间用于归并。</p>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h1007sjs4pj30py0laaes.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def mergeSort(alist):</span><br><span class="line">    print(&quot;Splitting &quot;,alist)</span><br><span class="line">    if len(alist)&gt;1:</span><br><span class="line">        mid = len(alist)//2</span><br><span class="line">        lefthalf = alist[:mid]</span><br><span class="line">        righthalf = alist[mid:]</span><br><span class="line"></span><br><span class="line">        mergeSort(lefthalf)</span><br><span class="line">        mergeSort(righthalf)</span><br><span class="line"></span><br><span class="line">        i=0</span><br><span class="line">        j=0</span><br><span class="line">        k=0</span><br><span class="line">        while i&lt;len(lefthalf) and j&lt;len(righthalf):</span><br><span class="line">            if lefthalf[i]&lt;righthalf[j]:</span><br><span class="line">                alist[k]=lefthalf[i]</span><br><span class="line">                i=i+1</span><br><span class="line">            else:</span><br><span class="line">                alist[k]=righthalf[j]</span><br><span class="line">                j=j+1</span><br><span class="line">            k=k+1</span><br><span class="line"></span><br><span class="line">        while i&lt;len(lefthalf):</span><br><span class="line">            alist[k]=lefthalf[i]</span><br><span class="line">            i=i+1</span><br><span class="line">            k=k+1</span><br><span class="line"></span><br><span class="line">        while j&lt;len(righthalf):</span><br><span class="line">            alist[k]=righthalf[j]</span><br><span class="line">            j=j+1</span><br><span class="line">            k=k+1</span><br><span class="line">    print(&quot;Merging &quot;,alist)</span><br><span class="line">    </span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">mergeSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<h3 id="快速排序：o-n-log-n"><a href="#快速排序：o-n-log-n" class="headerlink" title="快速排序：o(n*log n)"></a>快速排序：o(n*log n)</h3><p>快速排序是一个递归算法，思路是依据一个“中值”数据项来把数据表分为两半：小于中值的一半和大于中值的一半，然后每部分分别进行快速排序（递归） 。</p>
<p>递归三要素”如下 ：</p>
<ul>
<li>基本结束条件：数据表仅有1个数据项，自然是排好序的 </li>
<li>缩小规模：根据“中值”，将数据表分为两半，最好情况是相等规模的两半 </li>
<li>调用自身：将两半分别调用自身进行排序（排序基本操作在分裂过程中）</li>
</ul>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h12cu5uv5cj31hc0u019o.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">def quickSort(alist):</span><br><span class="line">   quickSortHelper(alist,0,len(alist)-1)</span><br><span class="line"></span><br><span class="line">def quickSortHelper(alist,first,last):</span><br><span class="line">   if first&lt;last:</span><br><span class="line"></span><br><span class="line">       splitpoint = partition(alist,first,last)</span><br><span class="line"></span><br><span class="line">       quickSortHelper(alist,first,splitpoint-1)</span><br><span class="line">       quickSortHelper(alist,splitpoint+1,last)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def partition(alist,first,last):</span><br><span class="line">   pivotvalue = alist[first]</span><br><span class="line"></span><br><span class="line">   leftmark = first+1</span><br><span class="line">   rightmark = last</span><br><span class="line"></span><br><span class="line">   done = False</span><br><span class="line">   while not done:</span><br><span class="line"></span><br><span class="line">       while leftmark &lt;= rightmark and \</span><br><span class="line">               alist[leftmark] &lt;= pivotvalue:</span><br><span class="line">           leftmark = leftmark + 1</span><br><span class="line"></span><br><span class="line">       while alist[rightmark] &gt;= pivotvalue and \</span><br><span class="line">               rightmark &gt;= leftmark:</span><br><span class="line">           rightmark = rightmark -1</span><br><span class="line"></span><br><span class="line">       if rightmark &lt; leftmark:</span><br><span class="line">           done = True</span><br><span class="line">       else:</span><br><span class="line">           temp = alist[leftmark]</span><br><span class="line">           alist[leftmark] = alist[rightmark]</span><br><span class="line">           alist[rightmark] = temp</span><br><span class="line"></span><br><span class="line">   temp = alist[first]</span><br><span class="line">   alist[first] = alist[rightmark]</span><br><span class="line">   alist[rightmark] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return rightmark</span><br><span class="line">   </span><br><span class="line">alist = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">quickSort(alist)</span><br><span class="line">print(alist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="“堆排序”算法：O-nlog-n"><a href="#“堆排序”算法：O-nlog-n" class="headerlink" title="“堆排序”算法：O(nlog n)"></a>“堆排序”算法：O(nlog n)</h3><p>二叉堆来进行排序 ，详见“树 -&gt; 优先队列”</p>
<h2 id="9-树"><a href="#9-树" class="headerlink" title="9.树"></a>9.树</h2><h3 id="嵌套列表法"><a href="#嵌套列表法" class="headerlink" title="嵌套列表法"></a>嵌套列表法</h3><p>嵌套列表实现二叉树：[root,left,right]</p>
<p>优点：子树的结构与树相同，是一种递归数据结构很容易扩展到多叉树，仅需要增加列表元素即可 。</p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h13jycmv7dj30r4091god.jpg"></p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h13k3nlg8yj30fe05t0vp.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">def BinaryTree(r):</span><br><span class="line">    return [r, [], []]    </span><br><span class="line"></span><br><span class="line">def insertLeft(root,newBranch):</span><br><span class="line">    t = root.pop(1)</span><br><span class="line">    if len(t) &gt; 1:</span><br><span class="line">        root.insert(1,[newBranch,t,[]])</span><br><span class="line">    else:</span><br><span class="line">        root.insert(1,[newBranch, [], []])</span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">def insertRight(root,newBranch):</span><br><span class="line">    t = root.pop(2)</span><br><span class="line">    if len(t) &gt; 1:</span><br><span class="line">        root.insert(2,[newBranch,[],t])</span><br><span class="line">    else:</span><br><span class="line">        root.insert(2,[newBranch,[],[]])</span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">def getRootVal(root):</span><br><span class="line">    return root[0]</span><br><span class="line"></span><br><span class="line">def setRootVal(root,newVal):</span><br><span class="line">    root[0] = newVal</span><br><span class="line"></span><br><span class="line">def getLeftChild(root):</span><br><span class="line">    return root[1]</span><br><span class="line"></span><br><span class="line">def getRightChild(root):</span><br><span class="line">    return root[2]</span><br><span class="line"></span><br><span class="line">r = BinaryTree(3)</span><br><span class="line">insertLeft(r,4)</span><br><span class="line">insertLeft(r,5)</span><br><span class="line">insertRight(r,6)</span><br><span class="line">insertRight(r,7)</span><br><span class="line">l = getLeftChild(r)</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">setRootVal(l,9)</span><br><span class="line">print(r)</span><br><span class="line">insertLeft(l,11)</span><br><span class="line">print(r)</span><br><span class="line">print(getRightChild(getRightChild(r)))</span><br></pre></td></tr></table></figure>

<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class BinaryTree:</span><br><span class="line">    def __init__(self,rootObj):</span><br><span class="line">        self.key = rootObj</span><br><span class="line">        self.leftChild = None</span><br><span class="line">        self.rightChild = None</span><br><span class="line"></span><br><span class="line">    def insertLeft(self,newNode):</span><br><span class="line">        if self.leftChild == None:</span><br><span class="line">            self.leftChild = BinaryTree(newNode)</span><br><span class="line">        else:  </span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.leftChild = self.leftChild</span><br><span class="line">            self.leftChild = t</span><br><span class="line"></span><br><span class="line">    def insertRight(self,newNode):</span><br><span class="line">        if self.rightChild == None:</span><br><span class="line">            self.rightChild = BinaryTree(newNode)</span><br><span class="line">        else:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.rightChild = self.rightChild</span><br><span class="line">            self.rightChild = t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def getRightChild(self):</span><br><span class="line">        return self.rightChild</span><br><span class="line"></span><br><span class="line">    def getLeftChild(self):</span><br><span class="line">        return self.leftChild</span><br><span class="line"></span><br><span class="line">    def setRootVal(self,obj):</span><br><span class="line">        self.key = obj</span><br><span class="line"></span><br><span class="line">    def getRootVal(self):</span><br><span class="line">        return self.key                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = BinaryTree(&#x27;a&#x27;)</span><br><span class="line">print(r.getRootVal())</span><br><span class="line">print(r.getLeftChild())</span><br><span class="line">r.insertLeft(&#x27;b&#x27;)</span><br><span class="line">print(r.getLeftChild())</span><br><span class="line">print(r.getLeftChild().getRootVal())</span><br><span class="line">r.insertRight(&#x27;c&#x27;)</span><br><span class="line">print(r.getRightChild())</span><br><span class="line">print(r.getRightChild().getRootVal())</span><br><span class="line">r.getRightChild().setRootVal(&#x27;hello&#x27;)</span><br><span class="line">print(r.getRightChild().getRootVal())</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>三种遍历方式：</p>
<ul>
<li><p>前序遍历（preorder）：先访问根节点，再递归地前序访问左子树、最后前序访问右子树； </p>
</li>
<li><p>中序遍历（inorder）：先递归地中序访问左子树，再访问根节点，最后中序访问右子树； </p>
</li>
<li><p>后序遍历（postorder）：先递归地后序访问左子树，再后序访问右子树，最后访问根节点。</p>
</li>
</ul>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h15t08c3kzj30kg0ecwi0.jpg"></p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h15tazuikij30j40f5jz5.jpg"></p>
<h3 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h3><p><strong>深度优先搜索</strong>，计算左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 ：max(l,r)+1 ，<strong>递归</strong>计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def deepfind(tree):</span><br><span class="line">    if tree:</span><br><span class="line">        leftdeep = deepfind(tree.left)</span><br><span class="line">        rightdeep = deepfind(tree.right)</span><br><span class="line">        return max(leftdeep,rightdeep)+1</span><br><span class="line">    else:</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure>



<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>但在优先队列内部，数据项的次序却是由“优先级”来确定 ，高优先级的数据项排在队首，而低优先级的数据项则排在后面。这样，优先队列的入队操作就比较复杂，需要将数据项根据其优先级尽量挤到队列前方。 </p>
<p><strong>二叉堆</strong>Binary Heap实现优先队列（入队、出队复杂度都为**o(log n)**）</p>
<ul>
<li>insert(key)：新key加在列表末尾，显然无法保持“堆”次序虽然对其它路径的次序没有影响，但对于其到根的路径可能破坏次序 。需要将新key沿着路径来“上浮”到其正确位置注意：新key的“上浮”不会影响其它路径节点的“堆”次序 。</li>
</ul>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h15vuk2wctj30wo07x79a.jpg"></p>
<ul>
<li>delMin()：移走整个堆中最小的key:根节点heapList[1]，将新的根节点沿着一条路径“下沉”，直到比两个子节点都小 ，如果比子节点大，那么<strong>选择较小的子节点交换下沉</strong> 。</li>
</ul>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h15w3d4cnyj30r905u40i.jpg"></p>
<ul>
<li>buildHeap(lst)方法：从无序表生成“堆”</li>
</ul>
<p>用“下沉”法，能够将总代价控制在O(n) ，</p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1714ip5voj30l307iab7.jpg"></p>
<p>二叉堆的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class BinHeap:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.heapList = [0]</span><br><span class="line">        self.currentSize = 0</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    def percUp(self,i):</span><br><span class="line">        while i // 2 &gt; 0:</span><br><span class="line">          if self.heapList[i] &lt; self.heapList[i // 2]:</span><br><span class="line">             tmp = self.heapList[i // 2]</span><br><span class="line">             self.heapList[i // 2] = self.heapList[i]</span><br><span class="line">             self.heapList[i] = tmp</span><br><span class="line">          i = i // 2</span><br><span class="line">          </span><br><span class="line">    def insert(self,k):</span><br><span class="line">      self.heapList.append(k)</span><br><span class="line">      self.currentSize = self.currentSize + 1</span><br><span class="line">      self.percUp(self.currentSize)</span><br><span class="line">  </span><br><span class="line">    def percDown(self,i):</span><br><span class="line">      while (i * 2) &lt;= self.currentSize:</span><br><span class="line">          mc = self.minChild(i)</span><br><span class="line">          if self.heapList[i] &gt; self.heapList[mc]:</span><br><span class="line">              tmp = self.heapList[i]</span><br><span class="line">              self.heapList[i] = self.heapList[mc]</span><br><span class="line">              self.heapList[mc] = tmp</span><br><span class="line">          i = mc</span><br><span class="line"></span><br><span class="line">    def minChild(self,i):</span><br><span class="line">      if i * 2 + 1 &gt; self.currentSize:</span><br><span class="line">          return i * 2</span><br><span class="line">      else:</span><br><span class="line">          if self.heapList[i*2] &lt; self.heapList[i*2+1]:</span><br><span class="line">              return i * 2</span><br><span class="line">          else:</span><br><span class="line">              return i * 2 + 1</span><br><span class="line">          </span><br><span class="line">    def delMin(self):</span><br><span class="line">      retval = self.heapList[1]</span><br><span class="line">      self.heapList[1] = self.heapList[self.currentSize]</span><br><span class="line">      self.currentSize = self.currentSize - 1</span><br><span class="line">      self.heapList.pop()</span><br><span class="line">      self.percDown(1)</span><br><span class="line">      return retval</span><br><span class="line">  </span><br><span class="line">    def buildHeap(self,alist):</span><br><span class="line">      i = len(alist) // 2</span><br><span class="line">      self.currentSize = len(alist)</span><br><span class="line">      self.heapList = [0] + alist[:]</span><br><span class="line">      while (i &gt; 0):</span><br><span class="line">          self.percDown(i)</span><br><span class="line">          i = i - 1</span><br><span class="line">              </span><br><span class="line">bh = BinHeap()</span><br><span class="line">bh.buildHeap([9,5,6,2,3])</span><br><span class="line"></span><br><span class="line">print(bh.delMin())</span><br><span class="line">print(bh.delMin())</span><br><span class="line">print(bh.delMin())</span><br><span class="line">print(bh.delMin())</span><br><span class="line">print(bh.delMin())</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。</p>
<p>按照70,31,93,94,14,23,73的顺序插入：首先插入的70成为树根，31比70小，放到左子节点，93比70大，放到右子节点，94比93大，放到右子节点，14比31小，放到左子节点，23比14大，放到其右73比93小，放到其左  </p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h185o1rywhj30ae08vglv.jpg"></p>
<pre><code>class TreeNode:
    def __init__(self,key,val,left=None,right=None,parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    def hasLeftChild(self):
        return self.leftChild

    def hasRightChild(self):
        return self.rightChild

    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    def isRoot(self):
        return not self.parent

    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    def replaceNodeData(self,key,value,lc,rc):
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self

class BinarySearchTree:

    def __init__(self):
        self.root = None
        self.size = 0

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()
        
    def put(self,key,val):
        if self.root:
            self._put(key,val,self.root)
        else:
            self.root = TreeNode(key,val)
        self.size = self.size + 1

    def _put(self,key,val,currentNode):
        if key &lt; currentNode.key:
            if currentNode.hasLeftChild():
                   self._put(key,val,currentNode.leftChild)
            else:
                   currentNode.leftChild = TreeNode(key,val,parent=currentNode)
        else:
            if currentNode.hasRightChild():
                   self._put(key,val,currentNode.rightChild)
            else:
                   currentNode.rightChild = TreeNode(key,val,parent=currentNode)
                   
    def __setitem__(self,k,v):
       self.put(k,v)
       
    def get(self,key):
       if self.root:
           res = self._get(key,self.root)
           if res:
                  return res.payload
           else:
                  return None
       else:
           return None

    def _get(self,key,currentNode):
       if not currentNode:
           return None
       elif currentNode.key == key:
           return currentNode
       elif key &lt; currentNode.key:
           return self._get(key,currentNode.leftChild)
       else:
           return self._get(key,currentNode.rightChild)

    def __getitem__(self,key):
       return self.get(key)

    def __contains__(self,key):
       if self._get(key,self.root):
           return True
       else:
           return False

    def delete(self,key):
      if self.size &gt; 1:
         nodeToRemove = self._get(key,self.root)
         if nodeToRemove:
             self.remove(nodeToRemove)
             self.size = self.size-1
         else:
             raise KeyError(&#39;Error, key not in tree&#39;)
      elif self.size == 1 and self.root.key == key:
         self.root = None
         self.size = self.size - 1
      else:
         raise KeyError(&#39;Error, key not in tree&#39;)

    def __delitem__(self,key):
       self.delete(key)

    def spliceOut(self):
       if self.isLeaf():
           if self.isLeftChild():
                  self.parent.leftChild = None
           else:
                  self.parent.rightChild = None
       elif self.hasAnyChildren():
           if self.hasLeftChild():
                  if self.isLeftChild():
                     self.parent.leftChild = self.leftChild
                  else:
                     self.parent.rightChild = self.leftChild
                  self.leftChild.parent = self.parent
           else:
                  if self.isLeftChild():
                     self.parent.leftChild = self.rightChild
                  else:
                     self.parent.rightChild = self.rightChild
                  self.rightChild.parent = self.parent

    def findSuccessor(self):
      succ = None
      if self.hasRightChild():
          succ = self.rightChild.findMin()
      else:
          if self.parent:
                 if self.isLeftChild():
                     succ = self.parent
                 else:
                     self.parent.rightChild = None
                     succ = self.parent.findSuccessor()
                     self.parent.rightChild = self
      return succ

    def findMin(self):
      current = self
      while current.hasLeftChild():
          current = current.leftChild
      return current

    def remove(self,currentNode):
     if currentNode.isLeaf(): #leaf
       if currentNode == currentNode.parent.leftChild:
           currentNode.parent.leftChild = None
       else:
           currentNode.parent.rightChild = None
     elif currentNode.hasBothChildren(): #interior
       succ = currentNode.findSuccessor()
       succ.spliceOut()
       currentNode.key = succ.key
       currentNode.payload = succ.payload

     else: # this node has one child
       if currentNode.hasLeftChild():
         if currentNode.isLeftChild():
             currentNode.leftChild.parent = currentNode.parent
             currentNode.parent.leftChild = currentNode.leftChild
         elif currentNode.isRightChild():
             currentNode.leftChild.parent = currentNode.parent
             currentNode.parent.rightChild = currentNode.leftChild
         else:
             currentNode.replaceNodeData(currentNode.leftChild.key,
                                currentNode.leftChild.payload,
                                currentNode.leftChild.leftChild,
                                currentNode.leftChild.rightChild)
       else:
         if currentNode.isLeftChild():
             currentNode.rightChild.parent = currentNode.parent
             currentNode.parent.leftChild = currentNode.rightChild
         elif currentNode.isRightChild():
             currentNode.rightChild.parent = currentNode.parent
             currentNode.parent.rightChild = currentNode.rightChild
         else:
             currentNode.replaceNodeData(currentNode.rightChild.key,
                                currentNode.rightChild.payload,
                                currentNode.rightChild.leftChild,
                                currentNode.rightChild.rightChild)
</code></pre>
<p>​<br>    mytree &#x3D; BinarySearchTree()<br>    mytree[3]&#x3D;”red”<br>    mytree[4]&#x3D;”blue”<br>    mytree[6]&#x3D;”yellow”<br>    mytree[2]&#x3D;”at”</p>
<pre><code>print(3 in mytree)
print(mytree[6])
del mytree[2]
print(mytree[2])
</code></pre>
<p>​<br>​    </p>
<h3 id="平衡二叉查找树：AVL树-o-log-n"><a href="#平衡二叉查找树：AVL树-o-log-n" class="headerlink" title="平衡二叉查找树：AVL树 o(log n)"></a>平衡二叉查找树：AVL树 o(log n)</h3><p>AVL树的实现中，需要对每个节点跟踪“平衡因子balancefactor”参数 ，平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差： balanceFactor &#x3D; height(leftSubTree) − height(rightSubTree)，如果平衡因子大于0，称为“左重left-heavy”，小于零称为“右重right-heavy”，平衡因子等于0，则称作平衡。有节点的平衡因子超出此范围，则需要一个重新平衡的过程，<strong>要保持BST的性质！</strong> </p>
<h2 id="力扣笔记"><a href="#力扣笔记" class="headerlink" title="力扣笔记"></a>力扣笔记</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></h4><p>思路：在初始时，左右指针分别指向数组的左右两端，我们移动 <strong>数字较小的那个指针</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        i = 0</span><br><span class="line">        j = len(height) - 1</span><br><span class="line">        max = 0</span><br><span class="line">        while(i!=j):</span><br><span class="line">            if height[i] &gt; height[j]:</span><br><span class="line">                tmp = height[j] * (j-i)</span><br><span class="line">                if tmp &gt; max:</span><br><span class="line">                    max = tmp</span><br><span class="line">                j = j-1</span><br><span class="line">            else:</span><br><span class="line">                tmp = height[i] * (j-i)</span><br><span class="line">                if tmp &gt; max:</span><br><span class="line">                    max = tmp</span><br><span class="line">                i = i+1</span><br><span class="line">        </span><br><span class="line">        return max</span><br></pre></td></tr></table></figure>

<h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h3><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>思路：上方数组是输入，下方为构建的新数组，第二个元素开始从左到右判断前一个值是否大于零，若大于零则加在当前位置给新数组，否则把当前值给数组。</p>
<p>eg：1的前一个为-2，则把当前值1给数组；-3的前一个值为1大于0，则前一个值与当前值相加；4的前一个值为-2小于零，则把当前值4给数组……</p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h1hfyzmc81j30ug0bmgow.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i-1] &gt; 0:</span><br><span class="line">                nums[i] = nums[i] + nums[i-1]</span><br><span class="line">        return max(nums)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/C++%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/C++%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-06 15:41:01 / Modified: 16:19:19" itemprop="dateCreated datePublished" datetime="2022-04-06T15:41:01+08:00">2022-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开<br>作者邮箱：<a href="mailto:&#117;&#110;&#x69;&#113;&#117;&#x65;&#95;&#x68;&#x61;&#x6e;&#103;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#117;&#110;&#x69;&#113;&#117;&#x65;&#95;&#x68;&#x61;&#x6e;&#103;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<h2 id="1-Visual-Studio创建项目"><a href="#1-Visual-Studio创建项目" class="headerlink" title="1 Visual Studio创建项目"></a>1 Visual Studio创建项目</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h101omnsacj311y0k2qca.jpg" alt="1541383178746"></p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h101onxmi1j30q50fz456.jpg" alt="1541384366413"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h101onbybtj30v10dy0yn.jpg" alt="1541383817248"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h101onr3fej30q50fz0xd.jpg" alt="1541384140042"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h101oo88lsj30r70e8jso.jpg" alt="1541384818688"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，&#x3D;&#x3D;对该行代码说明&#x3D;&#x3D;</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，&#x3D;&#x3D;对该段代码做整体说明&#x3D;&#x3D;</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><p><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在文件上方定义&#x3D;&#x3D;，表示一个常量</li>
</ul>
</li>
<li><p><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在变量定义前加关键字const&#x3D;&#x3D;，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是&#x3D;&#x3D;整数类型&#x3D;&#x3D;的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以&#x3D;&#x3D;统计数据类型所占内存大小&#x3D;&#x3D;</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p><strong>整型结论</strong>：&#x3D;&#x3D;short &lt; int &lt;&#x3D; long &lt;&#x3D; long long&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于&#x3D;&#x3D;表示小数&#x3D;&#x3D;</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>&#x2F;</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>&#96;</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些&#x3D;&#x3D;不能显示出来的ASCII字符&#x3D;&#x3D;</p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>*<em>\\*</em></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件&#x3D;&#x3D;#include&lt;string&gt;&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）</li>
</ul>
<p><strong>bool类型占&#x3D;&#x3D;1个字节&#x3D;&#x3D;大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>10 &#x2F; 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a&#x3D;2; b&#x3D;++a;</td>
<td>a&#x3D;3; b&#x3D;3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a&#x3D;2; b&#x3D;a++;</td>
<td>a&#x3D;3; b&#x3D;2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a&#x3D;2; b&#x3D;–a;</td>
<td>a&#x3D;1; b&#x3D;1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a&#x3D;2; b&#x3D;a–;</td>
<td>a&#x3D;1; b&#x3D;2;</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;2; b&#x3D;3;</td>
<td>a&#x3D;2; b&#x3D;3;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;0; a+&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;5; a-&#x3D;3;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;2; a*&#x3D;2;</td>
<td>a&#x3D;4;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;4; a&#x2F;&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3; a%2;</td>
<td>a&#x3D;1;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>相等于</td>
<td>4 &#x3D;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>4 !&#x3D; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>4 &lt;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>4 &gt;&#x3D; 1</td>
<td>1</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C和C++ 语言的比较运算中， &#x3D;&#x3D;“真”用数字“1”来表示， “假”用数字“0”来表示。&#x3D;&#x3D; </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：逻辑&#x3D;&#x3D;与&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同真为真，其余为假&#x3D;&#x3D;</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>逻辑&#x3D;&#x3D;或&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同假为假，其余为真&#x3D;&#x3D;</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D;</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
<p>​</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h101oqac7zj304l067aa2.jpg" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol>
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
</ol>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h101y6d3zkj306006s74c.jpg" alt="img"></p>
<p>​</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<ol>
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h101y6k1puj30ac0a6mxk.jpg" alt="img"></p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？</p>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>&#x3D;&#x3D;只要循环条件的结果为真，就执行循环语句&#x3D;&#x3D;</p>
<p><img src="https://wx1.sinaimg.cn/mw2000/007BSstUgy1h101y7bfaaj304z06kweh.jpg" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>&#x3D;&#x3D;猜数字&#x3D;&#x3D;</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于&#x3D;&#x3D;do…while会先执行一次循环语句&#x3D;&#x3D;，再判断循环条件</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h101y7ml57j305b05z0sq.jpg" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 &#x3D; 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>详解：</strong></p>
<p><img src="https://wx2.sinaimg.cn/mw2000/007BSstUgy1h101oodvr6j30de07ognd.jpg" alt="1541673704101"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="https://wx3.sinaimg.cn/mw2000/007BSstUgy1h101oojguyj30cu08fq37.jpg" alt="1541676003486"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出&#x3D;&#x3D;选择结构&#x3D;&#x3D;或者&#x3D;&#x3D;循环结构&#x3D;&#x3D;</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在&#x3D;&#x3D;循环语句&#x3D;&#x3D;中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个&#x3D;&#x3D;数据元素都是相同的数据类型&#x3D;&#x3D;</p>
<p><strong>特点2：</strong>数组是由&#x3D;&#x3D;连续的内存&#x3D;&#x3D;位置组成的</p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] &#x3D; {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="https://wx4.sinaimg.cn/mw2000/007BSstUgy1h101ooxsr7j30qs037gls.jpg" alt="1541905327273"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用&#x3D;&#x3D;第二种更加直观，提高代码的可读性&#x3D;&#x3D;</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code> 函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，&#x3D;&#x3D;如果形参发生，并不会影响实参&#x3D;&#x3D;</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p>
</li>
<li><p>可以利用指针变量保存地址</p>
<p>​</p>
</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户&#x3D;&#x3D;自定义的数据类型&#x3D;&#x3D;，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>









<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/%E6%A0%BC%E5%BC%8F%E5%8C%96SD%E5%8D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/%E6%A0%BC%E5%BC%8F%E5%8C%96SD%E5%8D%A1/" class="post-title-link" itemprop="url">格式化SD卡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:21:33" itemprop="dateCreated datePublished" datetime="2022-04-05T15:21:33+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:26:11" itemprop="dateModified" datetime="2022-04-06T14:26:11+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<ul>
<li>右键菜单图标-&gt;运行-&gt;输入cmd-&gt;在命令提示符窗里输入“DISKPART”</li>
<li>在弹出的DISKPART窗口中输入“LIST DISK”</li>
<li>然后依次输入以下命令：（以磁盘2为SD卡为例）</li>
</ul>
<p>SELECT DISK 2：选中磁盘2。</p>
<p>CLEAN：删除整个磁盘数据。</p>
<p>CREATE PARTITION PRIMARY：创建主磁盘分区。</p>
<p>ACTIVE：激活磁盘分区。</p>
<p>FORMAT FS&#x3D;FAT32 QUICK：以FAT32格式快速格式化磁盘分区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">服务器初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:20:38" itemprop="dateCreated datePublished" datetime="2022-04-05T15:20:38+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:26:03" itemprop="dateModified" datetime="2022-04-06T14:26:03+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<h1 id="1、连接服务器"><a href="#1、连接服务器" class="headerlink" title="1、连接服务器"></a>1、连接服务器</h1><p>需要下载xshell 7和XFTP</p>
<p><a target="_blank" rel="noopener" href="https://www.netsarang.com/en/free-for-home-school/">下载链接</a></p>
<h1 id="2、创建账户"><a href="#2、创建账户" class="headerlink" title="2、创建账户"></a>2、创建账户</h1><p>步骤：</p>
<p><strong>1、创建新用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser USERNAME</span><br></pre></td></tr></table></figure>

<p>其中USERNAME是您要添加的用户的名称。</p>
<p><strong>2、给予sudo权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG sudo USER</span><br></pre></td></tr></table></figure>

<p>其中USER是新的用户名。</p>
<p><strong>3、修改默认目录,在root账户下输入（建文件夹时用自己的账户）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -d /tmp test</span><br></pre></td></tr></table></figure>

<p>tmp是默认目录，test为你的用户名</p>
<p><strong>4、查看用户路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat/etc/passwd</span><br></pre></td></tr></table></figure>



<h1 id="3、anaconda安装"><a href="#3、anaconda安装" class="headerlink" title="3、anaconda安装"></a>3、anaconda安装</h1><p>步骤：</p>
<p><strong>1、提前下载好Linux下的版本，（eg：Anaconda3-2019.07-Linux-x86_64.sh）</strong></p>
<p><strong>2、cd进入下载目录</strong></p>
<p><strong>3、安装请输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2019.07-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<p><strong>4、一直按回车，直到出现</strong></p>
<p><img src="https://wx3.sinaimg.cn/mw690/007BSstUgy1gmrns7s6fij30nb0bkgok.jpg"></p>
<p><strong>5、输入：yes接受</strong></p>
<p><img src="https://wx2.sinaimg.cn/mw690/007BSstUgy1gmrnu6kfn4j30lx07wdj4.jpg"></p>
<p><strong>6、这个地方就是说，Anaconda安装到默认目录下，安装好后你可以在该文件夹下看到安装文件，此处你用可以自己更改目录，我这个地方就用默认的，如何你用默认的就直接点击Enter，如果你想其他的你就自己输入路径。</strong></p>
<p><strong>7、接下来就是安装，最后会出现这样一个界面:</strong></p>
<p><img src="https://wx4.sinaimg.cn/mw690/007BSstUgy1gmrnua463oj30mr05yjtl.jpg"></p>
<p>这一步确认是否由Anaconda进行终端的初始化，一般选择yes，否则无法使用虚拟环境</p>
<p><strong>8、安装成功</strong></p>
<p><img src="https://wx4.sinaimg.cn/mw690/007BSstUgy1gmrnuj6yxyj30xr0nlnbn.jpg"></p>
<h1 id="4、anaconda配置"><a href="#4、anaconda配置" class="headerlink" title="4、anaconda配置"></a>4、anaconda配置</h1><p>在终端中输入conda，发现command not found，解决方法如下：</p>
<p>步骤：</p>
<p><strong>1、将anaconda的bin目录加入PATH（有新的虚拟环境也要加入PATH），输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/home/anaconda3/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>根据版本不同，也可能是~&#x2F;anaconda2&#x2F;bin</p>
<p><strong>2、更新bashrc以立即生效，输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>



<h1 id="5、创建一个python环境"><a href="#5、创建一个python环境" class="headerlink" title="5、创建一个python环境"></a>5、创建一个python环境</h1><p><strong>0、换源</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/</span><br><span class="line"></span><br><span class="line">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes </span><br><span class="line"></span><br><span class="line">conda config --get channels</span><br></pre></td></tr></table></figure>

<p><strong>1、查看当前存在哪些虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>

<p><strong>2、创建虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow2（自定义python名称） python=3.6 </span><br></pre></td></tr></table></figure>

<p><img src="https://wx2.sinaimg.cn/mw690/007BSstUgy1gmro4mvwqsj30jo0eo0vz.jpg"></p>
<p><strong>3、输入：y</strong></p>
<p><img src="https://wx2.sinaimg.cn/mw690/007BSstUgy1gmro4p92bbj306801cdfp.jpg"></p>
<p><strong>4、进入环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow2</span><br></pre></td></tr></table></figure>

<p><strong>5、安装自己所需的库</strong></p>
<h1 id="6、Tensorflow2的安装"><a href="#6、Tensorflow2的安装" class="headerlink" title="6、Tensorflow2的安装"></a>6、Tensorflow2的安装</h1><p><strong>1、tensorflow对应cuda的兼容版本问题</strong></p>
<p> <a target="_blank" rel="noopener" href="https://tensorflow.google.cn/install/source">官方网址</a></p>
<p><img src="https://wx1.sinaimg.cn/mw690/007BSstUgy1gmrofk0t2bj30yl0drwhs.jpg"></p>
<p><strong>2、下载tensorflow2.0.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#cpu</span><br><span class="line">pip install tensorflow==2.0.0-alpha0</span><br><span class="line">#gpu</span><br><span class="line">pip install tensorflow-gpu==2.0.0-alpha</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf2 python=3.8 cudatoolkit=10.1</span><br><span class="line"></span><br><span class="line">conda install tensorflow-gpu=2.3</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#940M也能跑</span><br><span class="line">conda create -n tf2 python=3.7 cudatoolkit=10 tensorflow-gpu=2.0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch1（替换成你想要的名字） pytorch torchvision cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure>



<p><strong>3、把cuda路径加入环境变量</strong></p>
<p>终端输入编辑环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc				</span><br></pre></td></tr></table></figure>

<p>强行写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：w！</span><br></pre></td></tr></table></figure>

<p>编辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>

<p>粘贴cuda路径如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#----------- This is PATH of CUDA10.0---------</span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.0</span><br><span class="line">export PATH=/usr/local/cuda-10.0/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda-10.0/lib64&quot;</span><br><span class="line">export LIBRARY_PATH=&quot;$LIBRARY_PATH:/usr/local/cuda-10.0/lib64&quot;</span><br><span class="line">#----------- This is PATH of CUDA10.0---------</span><br></pre></td></tr></table></figure>

<p>按Esc退出编辑后输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：wq</span><br></pre></td></tr></table></figure>

<p>更新配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p><strong>4、检查tensorflow-gpu是否可用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">print(tf.__version__)</span><br><span class="line">print(tf.test.is_gpu_available())</span><br></pre></td></tr></table></figure>

<p><strong>5、指定GPU训练</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#用第二张显卡训练</span><br><span class="line">CUDA_VISIBLE_DEVICES=1 python train.py</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">常遇到的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:20:14" itemprop="dateCreated datePublished" datetime="2022-04-05T15:20:14+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:25:57" itemprop="dateModified" datetime="2022-04-06T14:25:57+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<ul>
<li><strong>OSError: [WinError 1455] 页面文件太小，无法完成操作。 Error loading “C:\Anaconda3\lib\site-packages\torch\lib\caffe2_detectron_ops_gpu.dll”</strong></li>
</ul>
<p>把磁盘的虚拟内存调大；</p>
<p>“电脑”属性—&gt;“高级系统设置”按钮—&gt;“高级”选项卡—&gt;“性能相关”按钮—&gt;“高级”选项卡—&gt;更改—&gt;取消选择’自动’—&gt;对于所有的驱动器，设置“系统管理大小”，重启</p>
<p>- </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/windows%E5%AD%90%E7%B3%BB%E7%BB%9FLinux%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/windows%E5%AD%90%E7%B3%BB%E7%BB%9FLinux%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">windows子系统Linux技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:19:35" itemprop="dateCreated datePublished" datetime="2022-04-05T15:19:35+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:25:14" itemprop="dateModified" datetime="2022-04-06T14:25:14+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<p>密码：123456</p>
<p>换源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">更新源：</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>ubuntu重启：</p>
<p>在windows的cmd（管理员身份）窗口输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop LxssManager</span><br><span class="line"></span><br><span class="line">net start LxssManager</span><br></pre></td></tr></table></figure>

<p>ubuntu打开桌面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vncserver -geometry 1600x900 :0</span><br></pre></td></tr></table></figure>

<p>关闭桌面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vncserver -kill :0</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/win10%E9%85%8D%E7%BD%AEDetectron2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/win10%E9%85%8D%E7%BD%AEDetectron2/" class="post-title-link" itemprop="url">win10配置Detectron2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:19:03" itemprop="dateCreated datePublished" datetime="2022-04-05T15:19:03+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:25:01" itemprop="dateModified" datetime="2022-04-06T14:25:01+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<h1 id="超详细整理Detectron2目标检测源码在Win10下的环境配置"><a href="#超详细整理Detectron2目标检测源码在Win10下的环境配置" class="headerlink" title="超详细整理Detectron2目标检测源码在Win10下的环境配置"></a>超详细整理Detectron2目标检测源码在Win10下的环境配置</h1><iframe src="//player.bilibili.com/player.html?aid=806528217&bvid=BV1j34y1Z7y9&cid=440211186&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ol>
<li><strong>虚拟环境建立</strong><br>Anaconda输入如下指令：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">-n</span> detectron2 python=<span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<p>anaconda命令建立python版本为x.x，名字为your_name的虚拟环境。<strong>your_name文件能够在Anaconda安装目录envs文件下找到</strong>。</p>
<p>以后就会出现下图Package Plan界面<br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/2407912ba8c8428c95ecfa19ce161107-1.jpg" alt="在这里插入图片描述"><br>接着会让你安装python3.6相关依赖，输入y便可</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/1298839705084c759b8a3aa4eed696cc-1.jpg" alt="在这里插入图片描述"></p>
<p>继续等待其安装完成，直至出现以下界面，接着，咱们要激活咱们新建立的环境，由于咱们刚刚只是建立了，如今要予以激活，才能把咱们对应的库装入到咱们但愿配置的环境中去</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/15d7abe98e3a424585aa5bc16cfcdaeb-1.jpg" alt="在这里插入图片描述">紧接着再输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate detectron2</span><br></pre></td></tr></table></figure>

<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/3d8b72d85ccc4f88bb2afcbf0077b0f8-1.jpg" alt="在这里插入图片描述"><br>在C盘以前出现detectron2的字样表明激活成功。这里必定要注意，每一次重启cmd都须要从新激活一次咱们的虚拟环境，千万不要踩坑了呐~有好多小伙伴觉得activate了一次就觉得是永久的了，在这里注意一下，并非永久的！！</p>
<p>咱们以后都是须要在虚拟环境里安装库的，否则都是白费呐！</p>
<ol>
<li><p><strong>detectron2所需库的配置</strong><br>（1）首先咱们安装最基本的2个库numpy，matplotlib.这里就不过多赘述安装过程了。直接<code>pip/conda install numpy matplotlib</code>便可<br>（2）安装opencv-python，这一步是由于题主后续是训练本身的数据集的因此须要图片的读入，若是不须要训练本身的数据集，opencv安装能够跳过哦~ 对于安装opencv-python这里题主推荐几种方法：<br><strong>方法1</strong>：直接<code>pip install opencv-python</code>通常来讲就能够成功，相对来讲下载比较缓慢，并且常常可能下载会断orz<br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/05ebc57745db439e9c64b8c2087b8f0e-1.jpg" alt="在这里插入图片描述"></p>
<p><strong>方法二</strong>：在<a target="_blank" rel="noopener" href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84python%E7%89%88%E6%9C%AC%E5%92%8Cwindows%E7%B3%BB%E7%BB%9Fopencv%E7%9A%84whl%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E9%87%8C%E5%92%B1%E4%BB%AC%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFopencv_python-4.4.0-cp36-win_amd64.whl">https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv下载对应的python版本和windows系统opencv的whl文件，这里咱们选择的是opencv_python-4.4.0-cp36-win_amd64.whl</a><br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/ce7cac852c9f48e58645e6f11784fadc-1.jpg" alt="在这里插入图片描述"><br>下载完成后咱们把它放到桌面，以后继续在cmd窗口里进行操做。咱们在cmd窗口里输入<code>cd desktop</code></p>
<p>然后输入，注意这里仍是要在咱们构建的detectron2环境下安装哦，否则是无效的，若是不当心关闭了以前的cmd窗口，记得每开一次都要从新activate一下detectron2的环境。这里是个小坑，你们注意。</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv_python<span class="literal">-4</span>.<span class="number">4.0</span><span class="literal">-cp36-win_amd64</span>.whl</span><br></pre></td></tr></table></figure>

<p>显示以下：<br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/1ff7203d53be49b18997bc1fa64fbd54-1.jpg" alt="在这里插入图片描述"><br>（3）<strong>安装pillow，cython库</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow cython</span><br></pre></td></tr></table></figure>

<p>（4）<strong>Pytorch-gpu版 安装</strong><br>首先进入pytorch官网 <a target="_blank" rel="noopener" href="https://pytorch.org/">https://pytorch.org/</a><br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/6b42fda65b364b099ecbdb12fa963c8a-1.jpg" alt="在这里插入图片描述"><br>选择好对应的gpu版pytorch，有小伙伴可能在这里有疑问，为何不选conda而要选用pip，题主只能这么说，题主用conda总是装不上gpu版 torch，测试了几回，发现用pip相对来讲稳定一些，这里就回到了开题时候说的，pytorch&#x3D;1.6.0，配合cuda&#x3D;10.1经过题主后续的一系列测试，发如今detectron2上能够完美运行。因此小伙伴们能够放心大胆的进行配置~</p>
<p>固然啦，也不是说conda必定有问题，多是题主当时有问题~</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/d69074ad821048e3bd09e727eee858b6-1.jpg" alt="在这里插入图片描述"><br>直接在虚拟环境中输入相应的语句，等待其安装。</p>
<p>这里必定要<strong>注意</strong>，<strong>先安装对应版本的pytorch</strong>和torchvision，<strong>再去安装detectron2</strong>，由于每次安装完pytorch后，detectron2一般须要重装！！因此这里务必注意顺序！！！否则的话，很容易出现 “<strong>ImportError: cannot import name _C</strong>’”这个报错，若是出现这个报错，那么就须要从新安装一次detectron2，可是若是detectron2是在pytorch安装后安装就没有问题。</p>
<p>这里这个小坑能够注意一下！</p>
<p>安装完成以后咱们在cmd中输入python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"></span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>

<p>若是提示True,那么恭喜你大功告成，pytorch-gpu版安装完成，以后输入exit（）退出python</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/056cfc6bcab844729f06c9452eb736b1-1.jpg" alt="在这里插入图片描述">到这里一旦有显示True<br>那咱们的pytorch部分就配置完毕，gpu版得pytorch也大功告成~</p>
<p>（5）detectron2安装<br>在安装detectron2以前，还须要安装pycocotools，继续cmd，detectron2环境下继续安装：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/philferriere/cocoapi.git</span><br></pre></td></tr></table></figure>

<p>这里不用原始源是由于原始源不支持windows因此这里放的是支持windows的github地址。</p>
<p>在这里各位小伙伴若是报错以下：</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/50b222275cad49a7985379adba7a6024-1.jpg" alt="在这里插入图片描述"><br>那么就是说git没有安装，以后咱们在cmd中先输入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git</span><br></pre></td></tr></table></figure>

<p>若是这里pip也报错，那么就直接使用<code>conda install git</code>便可<br>以后继续运行pycocotools的安装语句，等待其完成，这里只要显示了Cloning通常不会失败，只有可能会掉网。</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/29883fc88a6c4ce1be197e0d256399dd-1.jpg" alt="在这里插入图片描述"><br>固然在这里也能够本身下载好对应网址的github，而后放在桌面，找到PythonAPI地址，以后输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="literal">-e</span>.</span><br></pre></td></tr></table></figure>

<p>千万不要漏了e后面的点！！！</p>
<p><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/a454341477924f58aab01cf36a550c6d-1.jpg" alt="在这里插入图片描述"><br>Pycocotools安装完成后，继续在cmd窗口中输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/facebookresearch/detectron2.git</span><br></pre></td></tr></table></figure>

<p>安装detectron2（和安装pycocotools同样，能够直接pip或者是下载好到桌面以后找到setup.py所在pip install -e.）<br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/8b7328a694e44d6f900869dbe0736a62-1.jpg" alt="在这里插入图片描述">安装完成后，咱们在cmd窗口里输入<code>conda list</code>这时候看到列表里已经有咱们装好的detectron2的库<br><img src="https://resource.shangmayuan.com/droxy-blog/2020/12/01/9df97f8d8bde48a280df895c78c4b30a-1.jpg" alt="在这里插入图片描述">这时候detectron2也大功告成了~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/win10_tf2_gpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="unique_Hang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="unique_Hang's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/win10_tf2_gpu/" class="post-title-link" itemprop="url">win10_tf2_gpu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 15:18:33" itemprop="dateCreated datePublished" datetime="2022-04-05T15:18:33+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 14:24:55" itemprop="dateModified" datetime="2022-04-06T14:24:55+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer" /> 

<p>Welcome to unique_Hang’s blog.</p>
<blockquote>
<p><strong>鲁迅说过：看unique_Hang博客的人颜值都很高！</strong>  </p>
<p>打不开图片可以鼠标右键点击“复制图片地址”在新窗口中打开</p>
<p> 作者邮箱：<a href="mailto:unique_hang@qq.com">unique_hang@qq.com</a><br>喜欢的小伙伴可以关注我的b站账号(<a target="_blank" rel="noopener" href="https://space.bilibili.com/290100464">https://space.bilibili.com/290100464</a>)  </p>
</blockquote>
<p>安装conda</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf2 python=3.8 cudatoolkit=10.1</span><br><span class="line"></span><br><span class="line">conda install tensorflow-gpu=2.3</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#940M也能跑</span><br><span class="line">conda create -n tf2 python=3.7 cudatoolkit=10 tensorflow-gpu=2.0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch1（替换成你想要的名字） pytorch torchvision cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">unique_Hang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">unique_Hang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
